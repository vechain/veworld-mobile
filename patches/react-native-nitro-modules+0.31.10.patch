diff --git a/node_modules/react-native-nitro-modules/android/build/generated/source/buildConfig/debug/com/margelo/nitro/BuildConfig.java b/node_modules/react-native-nitro-modules/android/build/generated/source/buildConfig/debug/com/margelo/nitro/BuildConfig.java
new file mode 100644
index 0000000..2454b64
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/generated/source/buildConfig/debug/com/margelo/nitro/BuildConfig.java
@@ -0,0 +1,12 @@
+/**
+ * Automatically generated file. DO NOT MODIFY
+ */
+package com.margelo.nitro;
+
+public final class BuildConfig {
+  public static final boolean DEBUG = Boolean.parseBoolean("true");
+  public static final String LIBRARY_PACKAGE_NAME = "com.margelo.nitro";
+  public static final String BUILD_TYPE = "debug";
+  // Field from default config.
+  public static final boolean IS_NEW_ARCHITECTURE_ENABLED = false;
+}
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/AnyMap.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/AnyMap.hpp
new file mode 100644
index 0000000..2aa0ff0
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/AnyMap.hpp
@@ -0,0 +1,216 @@
+//
+// Created by Marc Rousavy on 30.07.24.
+//
+
+#pragma once
+
+#include "NitroDefines.hpp"
+#include "Null.hpp"
+#include <map>
+#include <memory>
+#include <string>
+#include <unordered_map>
+#include <variant>
+#include <vector>
+
+namespace margelo::nitro {
+
+struct AnyValue;
+using AnyArray = std::vector<AnyValue>;
+using AnyObject = std::unordered_map<std::string, AnyValue>;
+
+using VariantType = std::variant<NullType, bool, double, int64_t, std::string, AnyArray, AnyObject>;
+struct AnyValue : VariantType {
+  using VariantType::variant;
+
+  AnyValue(const VariantType& variant) : VariantType(variant) {}
+  AnyValue(VariantType&& variant) : VariantType(std::move(variant)) {}
+};
+
+/**
+ * Represents a JS map-like object (`Record<K, V>`).
+ * This is essentially a wrapper around `std::unordered_map<string, variant<...>>`.
+ *
+ * Supported values are:
+ * 1. Primitives
+ * 2. Arrays of primitives
+ * 3. Objects of primitives
+ */
+class AnyMap final {
+private:
+  explicit AnyMap() {}
+  AnyMap(size_t size) {
+    _map.reserve(size);
+  }
+
+public:
+  /**
+   * Create a new `shared_ptr` instance of AnyMap.
+   */
+  static std::shared_ptr<AnyMap> make() {
+    return std::shared_ptr<AnyMap>(new AnyMap());
+  }
+  /**
+   * Create a new `shared_ptr` instance of AnyMap with the given amount of spaces pre-allocated.
+   */
+  static std::shared_ptr<AnyMap> make(size_t size) {
+    return std::shared_ptr<AnyMap>(new AnyMap(size));
+  }
+
+public:
+  /**
+   * Returns whether the map contains the given key, or not.
+   */
+  bool contains(const std::string& key) const;
+  /**
+   * Removes the given key from the map, leaving no value.
+   */
+  void remove(const std::string& key);
+  /**
+   * Deletes all keys and values inside the map.
+   */
+  void clear() noexcept;
+  /**
+   * Get all keys this `AnyMap` instance contains.
+   */
+  std::vector<std::string> getAllKeys() const;
+
+public:
+  /**
+   * Returns whether the value under the given key is a `null`.
+   * If the value is not a `null` (or there is no value at the given `key`), this returns `false`.
+   */
+  bool isNull(const std::string& key) const;
+  /**
+   * Returns whether the value under the given key is a `double`.
+   * If the value is not a `double` (or there is no value at the given `key`), this returns `false`.
+   */
+  bool isDouble(const std::string& key) const;
+  /**
+   * Returns whether the value under the given key is a `boolean`.
+   * If the value is not a `boolean` (or there is no value at the given `key`), this returns `false`.
+   */
+  bool isBoolean(const std::string& key) const;
+  /**
+   * Returns whether the value under the given key is a `bigint`.
+   * If the value is not a `bigint` (or there is no value at the given `key`), this returns `false`.
+   */
+  bool isBigInt(const std::string& key) const;
+  /**
+   * Returns whether the value under the given key is a `string`.
+   * If the value is not a `string` (or there is no value at the given `key`), this returns `false`.
+   */
+  bool isString(const std::string& key) const;
+  /**
+   * Returns whether the value under the given key is an array.
+   * If the value is not an array (or there is no value at the given `key`), this returns `false`.
+   */
+  bool isArray(const std::string& key) const;
+  /**
+   * Returns whether the value under the given key is an object.
+   * If the value is not an object (or there is no value at the given `key`), this returns `false`.
+   */
+  bool isObject(const std::string& key) const;
+
+public:
+  /**
+   * Returns the null value at the given `key`.
+   * If no `null` value exists at the given `key`, this method will throw.
+   */
+  NullType getNull(const std::string& key) const;
+  /**
+   * Returns the double value at the given `key`.
+   * If no `double` value exists at the given `key`, this method will throw.
+   */
+  double getDouble(const std::string& key) const;
+  /**
+   * Returns the boolean value at the given `key`.
+   * If no `boolean` value exists at the given `key`, this method will throw.
+   */
+  bool getBoolean(const std::string& key) const;
+  /**
+   * Returns the bigint value at the given `key`.
+   * If no `bigint` value exists at the given `key`, this method will throw.
+   */
+  int64_t getBigInt(const std::string& key) const;
+  /**
+   * Returns the string value at the given `key`.
+   * If no `string` value exists at the given `key`, this method will throw.
+   */
+  std::string getString(const std::string& key) const;
+  /**
+   * Returns the array value at the given `key`.
+   * If no array value exists at the given `key`, this method will throw.
+   */
+  AnyArray getArray(const std::string& key) const;
+  /**
+   * Returns the object value at the given `key`.
+   * If no object value exists at the given `key`, this method will throw.
+   */
+  AnyObject getObject(const std::string& key) const;
+
+  /**
+   * Get the value at the given `key` as it's boxed `AnyValue`.
+   * If no object value exists at the given `key`, this method will throw.
+   */
+  AnyValue getAny(const std::string& key) const;
+
+public:
+  /**
+   * Set the value at the given key to `null`.
+   * If the key already exists, this will overwrite the value at that `key`.
+   */
+  void setNull(const std::string& key);
+  /**
+   * Set the value at the given key to the given `double`.
+   * If the key already exists, this will overwrite the value at that `key`.
+   */
+  void setDouble(const std::string& key, double value);
+  /**
+   * Set the value at the given key to the given `boolean`.
+   * If the key already exists, this will overwrite the value at that `key`.
+   */
+  void setBoolean(const std::string& key, bool value);
+  /**
+   * Set the value at the given key to the given `bigint`.
+   * If the key already exists, this will overwrite the value at that `key`.
+   */
+  void setBigInt(const std::string& key, int64_t value);
+  /**
+   * Set the value at the given key to the given `string`.
+   * If the key already exists, this will overwrite the value at that `key`.
+   */
+  void setString(const std::string& key, const std::string& value);
+  /**
+   * Set the value at the given key to the given array.
+   * If the key already exists, this will overwrite the value at that `key`.
+   */
+  void setArray(const std::string& key, const AnyArray& value);
+  /**
+   * Set the value at the given key to the given object.
+   * If the key already exists, this will overwrite the value at that `key`.
+   */
+  void setObject(const std::string& key, const AnyObject& value);
+  /**
+   * Set the value at the given key to the given `AnyValue`.
+   * If the key already exists, this will overwrite the value at that `key`.
+   */
+  void setAny(const std::string& key, const AnyValue& value);
+
+public:
+  /**
+   * Get the actual C++ map that holds all keys and variant values.
+   */
+  const std::unordered_map<std::string, AnyValue>& getMap() const;
+
+public:
+  /**
+   * Merge all keys and values from given `other` `AnyMap` into this `AnyMap`.
+   */
+  void merge(const std::shared_ptr<AnyMap>& other);
+
+private:
+  std::unordered_map<std::string, AnyValue> _map;
+} SWIFT_NONCOPYABLE;
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/ArrayBuffer.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/ArrayBuffer.hpp
new file mode 100644
index 0000000..87e91ce
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/ArrayBuffer.hpp
@@ -0,0 +1,157 @@
+//
+//  ArrayBuffer.hpp
+//  react-native-nitro
+//
+//  Created by Marc Rousavy on 14.07.24.
+//
+
+#pragma once
+
+#include "BorrowingReference.hpp"
+#include "NitroDefines.hpp"
+#include <jsi/jsi.h>
+#include <thread>
+#include <vector>
+
+namespace margelo::nitro {
+
+using namespace facebook;
+
+using DeleteFn = std::function<void()>;
+
+/**
+ * Represents a raw byte buffer that can be read from-, and
+ * written to- from both JavaScript and C++.
+ * `ArrayBuffer` is not thread-safe and does not lock multi-thread access.
+ *
+ * `ArrayBuffer` can either be a `JSArrayBuffer`, or a `NativeArrayBuffer`.
+ * - `NativeArrayBuffer`: Created from native (C++), and can either own the memory (`isOwner()`), or borrow it.
+ * - `JSArrayBuffer`: Received from JS, and will only be alive for as long as the JS Runtime is actually alive.
+ *
+ * Also, an `ArrayBuffer` can either own it's memory, or just borrow it's memory.
+ * - Owning = the `ArrayBuffer`'s `data()` is alive as long as the `ArrayBuffer` is alive.
+ *   When this `ArrayBuffer` gets deleted, it will free the memory.
+ * - Borrowed = the `ArrayBuffer`'s `data()` might be deleted at any point from an external source (e.g. the JS garbage collector).
+ *   When this `ArrayBuffer` gets deleted, the memory will not be freed explicitly, as someone else owns it.
+ */
+class ArrayBuffer : public jsi::MutableBuffer {
+public:
+  ArrayBuffer() = default;
+  ArrayBuffer(const ArrayBuffer&) = delete;
+  ArrayBuffer(ArrayBuffer&&) = delete;
+  virtual ~ArrayBuffer() = default;
+
+public:
+  /**
+   * Returns whether this `ArrayBuffer` is actually owning the data,
+   * or if it is just borrowed from an external source (either a native
+   * memory that we didn't allocate, or from JS - which can be deleted at any point).
+   */
+  virtual bool isOwner() const noexcept = 0;
+
+public:
+  /**
+   * Create a new `NativeArrayBuffer` that wraps the given data (without copy) of the given size,
+   * and calls `deleteFunc` in which `data` should be deleted.
+   */
+  static std::shared_ptr<ArrayBuffer> wrap(uint8_t* NON_NULL data, size_t size, DeleteFn&& deleteFunc);
+  /**
+   * Create a new `NativeArrayBuffer` that copies the given data of the given size
+   * into a newly allocated buffer.
+   */
+  static std::shared_ptr<ArrayBuffer> copy(const uint8_t* NON_NULL data, size_t size);
+  /**
+   * Create a new `NativeArrayBuffer` that copies the given `std::vector`.
+   */
+  static std::shared_ptr<ArrayBuffer> copy(const std::vector<uint8_t>& data);
+  /**
+   * Create a new `NativeArrayBuffer` that moves the given `std::vector`.
+   */
+  static std::shared_ptr<ArrayBuffer> move(std::vector<uint8_t>&& data);
+  /**
+   * Create a new `NativeArrayBuffer` that copies the given `std::shared_ptr<ArrayBuffer>`.
+   */
+  static std::shared_ptr<ArrayBuffer> copy(const std::shared_ptr<ArrayBuffer>& buffer);
+  /**
+   * Create a new `NativeArrayBuffer` that allocates a new buffer of the given size.
+   */
+  static std::shared_ptr<ArrayBuffer> allocate(size_t size);
+};
+
+/**
+ * Represents an `ArrayBuffer` that is allocated on the native (C++) side.
+ * It can either be "owning" or "borrowing".
+ *
+ * - Owning = the `ArrayBuffer`'s `data()` is alive as long as the `ArrayBuffer` is alive.
+ *   When this `ArrayBuffer` gets deleted, it will free the memory.
+ * - Borrowed = the `ArrayBuffer`'s `data()` might be deleted at any point from an external source (e.g. the JS garbage collector).
+ *   When this `ArrayBuffer` gets deleted, the memory will not be freed explicitly, as someone else owns it.
+ *
+ * It is safe to access `data()` and `size()` from any Thread, but there are no synchronization/mutexes implemented by default.
+ */
+class NativeArrayBuffer final : public ArrayBuffer {
+public:
+  /**
+   * Create a new **owning** `ArrayBuffer`.
+   * The `ArrayBuffer` can be kept in memory, as C++ owns the data
+   * and will only delete it once this `ArrayBuffer` gets deleted.
+   *
+   * Once this `ArrayBuffer` goes out of scope, `deleteFunc` will be called.
+   * The caller is responsible for deleting the memory (`data`) here.
+   */
+  NativeArrayBuffer(uint8_t* NON_NULL data, size_t size, DeleteFn&& deleteFunc);
+  ~NativeArrayBuffer();
+
+public:
+  uint8_t* NON_NULL data() override;
+  size_t size() const override;
+  bool isOwner() const noexcept override;
+
+private:
+  uint8_t* NON_NULL _data;
+  size_t _size;
+  DeleteFn _deleteFunc;
+};
+
+/**
+ * Represents a JS-based `ArrayBuffer`.
+ *
+ * While it's underlying data might have been allocated on the native side (`NativeArrayBuffer`),
+ * we only have a JS reference to the `ArrayBuffer` object so it is considered a "borrowed"-resource.
+ *
+ * `data()` and `size()` can only be accessed synchronously on the JS Runtime Thread.
+ * If you want to access it elsewhere, copy the buffer first.
+ *
+ * If the JS ArrayBuffer (or it's JS Runtime) have already been deleted, `data()` returns `nullptr`.
+ */
+class JSArrayBuffer final : public ArrayBuffer {
+public:
+  explicit JSArrayBuffer(jsi::Runtime& runtime, BorrowingReference<jsi::ArrayBuffer> jsReference);
+  ~JSArrayBuffer();
+
+public:
+  /**
+   * Gets the data this `ArrayBuffer` points to, or `nullptr` if it has already been deleted.
+   */
+  uint8_t* NULLABLE data() override;
+  /**
+   * Gets the size of the data this `ArrayBuffer` points to, or `0` if it has already been deleted.
+   */
+  size_t size() const override;
+  /**
+   * Returns `false` for JS-based ArrayBuffers.
+   */
+  bool isOwner() const noexcept override;
+
+public:
+  BorrowingReference<jsi::ArrayBuffer> getJSReference() const noexcept {
+    return _jsReference;
+  }
+
+private:
+  jsi::Runtime& _runtime;
+  BorrowingReference<jsi::ArrayBuffer> _jsReference;
+  std::thread::id _initialThreadId;
+};
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/AssertPromiseState.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/AssertPromiseState.hpp
new file mode 100644
index 0000000..c89cc02
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/AssertPromiseState.hpp
@@ -0,0 +1,34 @@
+//
+//  AssertPromiseState.hpp
+//  NitroModules
+//
+//  Created by Marc Rousavy on 20.11.24.
+//
+
+#pragma once
+
+namespace margelo::nitro {
+template <typename TResult>
+class Promise;
+} // namespace margelo::nitro
+
+#include "NitroTypeInfo.hpp"
+#include "Promise.hpp"
+#include <exception>
+#include <string>
+
+namespace margelo::nitro {
+
+enum PromiseTask { WANTS_TO_RESOLVE, WANTS_TO_REJECT };
+
+template <typename TResult>
+void assertPromiseState(Promise<TResult>& promise, PromiseTask task) {
+  if (!promise.isPending()) [[unlikely]] {
+    std::string taskString = task == WANTS_TO_RESOLVE ? "resolve" : "reject";
+    std::string state = promise.isResolved() ? "resolved" : "rejected";
+    throw std::runtime_error("Cannot " + taskString + " Promise<" + TypeInfo::getFriendlyTypename<TResult>() + "> - it is already " +
+                             state + "!");
+  }
+}
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/BorrowingReference.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/BorrowingReference.hpp
new file mode 100644
index 0000000..05b162c
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/BorrowingReference.hpp
@@ -0,0 +1,223 @@
+//
+//  BorrowingReference.hpp
+//  react-native-nitro
+//
+//  Created by Marc Rousavy on 23.06.24.
+//
+
+#pragma once
+
+#include "NitroDefines.hpp"
+#include "NitroTypeInfo.hpp"
+#include "ReferenceState.hpp"
+#include "WeakReference.hpp"
+#include <atomic>
+#include <cstddef>
+#include <mutex>
+
+namespace margelo::nitro {
+
+/**
+ * An `BorrowingReference<T>` is a smart-pointer that holds a strong reference to a pointer.
+ * You can have multiple `BorrowingReference<T>` instances point to the same pointer, as they internally keep a ref-count.
+ * As opposed to a `shared_ptr<T>`, an `BorrowingReference<T>` can also be imperatively manually deleted, even if there
+ * are multiple strong references still holding onto the pointer.
+ * This is useful in cases where the `BorrowingReference` might keep a reference alive, but an external value holder
+ * is actually responsible for truly deleting the underlying value - like a `jsi::Runtime` for a `jsi::Value`.
+ *
+ * An `BorrowingReference<T>` can be weakified, which gives the user a `WeakReference<T>`.
+ * A `WeakReference<T>` can be locked to get an `BorrowingReference<T>` again, assuming it has not been deleted yet.
+ */
+template <typename T>
+class BorrowingReference final {
+public:
+  BorrowingReference() : _value(nullptr), _state(nullptr) {}
+
+  explicit BorrowingReference(T* NULLABLE value) : _value(value), _state(new ReferenceState()) {}
+
+  BorrowingReference(const BorrowingReference& ref) : _value(ref._value), _state(ref._state) {
+    if (_state != nullptr) {
+      // increment ref count after copy
+      _state->strongRefCount++;
+    }
+  }
+
+  BorrowingReference(BorrowingReference&& ref) noexcept : _value(ref._value), _state(ref._state) {
+    ref._value = nullptr;
+    ref._state = nullptr;
+  }
+
+  BorrowingReference& operator=(const BorrowingReference& ref) {
+    if (this == &ref)
+      return *this;
+
+    if (_state != nullptr) {
+      // destroy previous pointer
+      bool shouldDestroy = _state->decrementStrongRefCount();
+      if (shouldDestroy) {
+        forceDestroyValue();
+      }
+      maybeDestroyState();
+    }
+
+    _value = ref._value;
+    _state = ref._state;
+    if (_state != nullptr) {
+      // increment new pointer
+      _state->strongRefCount++;
+    }
+
+    return *this;
+  }
+
+private:
+  // WeakReference<T> -> BorrowingReference<T> Lock-constructor
+  explicit BorrowingReference(const WeakReference<T>& ref) : _value(ref._value), _state(ref._state) {
+    _state->strongRefCount++;
+  }
+
+private:
+  // BorrowingReference<C> -> BorrowingReference<T> Cast-constructor
+  template <typename OldT>
+  BorrowingReference(T* NULLABLE value, const BorrowingReference<OldT>& originalRef) : _value(value), _state(originalRef._state) {
+    _state->strongRefCount++;
+  }
+
+  template <typename C>
+  friend class BorrowingReference;
+
+public:
+  ~BorrowingReference() {
+    if (_state == nullptr) {
+      // we are just a dangling nullptr.
+      return;
+    }
+
+    // decrement strong ref count on destroy
+    bool shouldDestroy = _state->decrementStrongRefCount();
+    if (shouldDestroy) {
+      forceDestroyValue();
+    }
+    maybeDestroyState();
+  }
+
+public:
+  /**
+   * Casts this `BorrowingReference<T>` to a `BorrowingReference<C>`.
+   */
+  template <typename C>
+  BorrowingReference<C> as() {
+    return BorrowingReference<C>(static_cast<C*>(_value), *this);
+  }
+
+public:
+  /**
+   * Get whether the `BorrowingReference<T>` is still pointing to a valid value, or not.
+   */
+  [[nodiscard]]
+  inline bool hasValue() const {
+    return _value != nullptr && !_state->isDeleted;
+  }
+
+  /**
+   * Get a borrowing (or "weak") reference to this owning reference
+   */
+  [[nodiscard]]
+  WeakReference<T> weak() const {
+    return WeakReference(*this);
+  }
+
+  /**
+   * Delete and destroy the value this BorrowingReference is pointing to.
+   * This can even be called if there are still multiple strong references to the value.
+   */
+  void destroy() {
+    std::unique_lock lock(_state->mutex);
+
+    forceDestroyValue();
+  }
+
+public:
+  // Dereference (*)
+  inline T& operator*() const {
+#ifdef NITRO_DEBUG
+    if (!hasValue()) [[unlikely]] {
+      std::string typeName = TypeInfo::getFriendlyTypename<T>(true);
+      throw std::runtime_error("Tried to dereference (*) nullptr BorrowingReference<" + typeName + ">!");
+    }
+#endif
+    return *_value;
+  }
+
+  // Dereference (->)
+  inline T* NON_NULL operator->() const {
+#ifdef NITRO_DEBUG
+    if (!hasValue()) [[unlikely]] {
+      std::string typeName = TypeInfo::getFriendlyTypename<T>(true);
+      throw std::runtime_error("Tried to dereference (->) nullptr BorrowingReference<" + typeName + ">!");
+    }
+#endif
+    return _value;
+  }
+
+  // null-check (bool)
+  explicit inline operator bool() const {
+    return hasValue();
+  }
+  // null-check (== nullptr)
+  inline bool operator==(std::nullptr_t) const {
+    return !hasValue();
+  }
+  // null-check (!= nullptr)
+  inline bool operator!=(std::nullptr_t) const {
+    return hasValue();
+  }
+
+  // comparison (== *)
+  inline bool operator==(T* NULLABLE other) const {
+    return _value == other;
+  }
+  // comparison (!= *)
+  inline bool operator!=(T* NULLABLE other) const {
+    return _value != other;
+  }
+
+  // comparison (== BorrowingReference<T>)
+  inline bool operator==(const BorrowingReference<T>& other) const {
+    return _value == other._value;
+  }
+  // comparison (!= BorrowingReference<T>)
+  inline bool operator!=(const BorrowingReference<T>& other) const {
+    return _value != other._value;
+  }
+
+private:
+  void maybeDestroyState() {
+    if (_state->strongRefCount == 0 && _state->weakRefCount == 0) {
+      // free the full memory if there are no more references at all
+      delete _state;
+      _state = nullptr;
+    }
+  }
+
+  void forceDestroyValue() {
+    if (_state->isDeleted) [[unlikely]] {
+      // it has already been destroyed.
+      return;
+    }
+    delete _value;
+    _value = nullptr;
+    _state->isDeleted = true;
+  }
+
+public:
+  friend class WeakReference<T>;
+
+private:
+  T* NULLABLE _value;
+  ReferenceState* NON_NULL _state;
+};
+
+} // namespace margelo::nitro
+
+#include "WeakReference+Owning.hpp"
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/BoxedHybridObject.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/BoxedHybridObject.hpp
new file mode 100644
index 0000000..2f44481
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/BoxedHybridObject.hpp
@@ -0,0 +1,36 @@
+//
+// Created by Marc Rousavy on 21.02.24.
+//
+
+#pragma once
+
+#include "HybridObject.hpp"
+#include <jsi/jsi.h>
+#include <memory>
+
+namespace margelo::nitro {
+
+using namespace facebook;
+
+/**
+ * Represents a `HybridObject` that has been boxed into a `jsi::HostObject`.
+ *
+ * While `HybridObject`s are runtime agnostic, some threading/worklet libraries do not support copying over objects
+ * with `jsi::NativeState` and a prototype chain (which is what a `HybridObject` is), so Nitro offers support for
+ * boxing those `HybridObject`s into a type that those libraries support - which is a `jsi::HostObject`.
+ *
+ * Simply call `unbox()` on this `jsi::HostObject` from the new Runtime/context to get the `HybridObject` again.
+ */
+class BoxedHybridObject final : public jsi::HostObject {
+public:
+  explicit BoxedHybridObject(const std::shared_ptr<HybridObject>& hybridObject) : _hybridObject(hybridObject) {}
+
+public:
+  jsi::Value get(jsi::Runtime& runtime, const jsi::PropNameID& propName) override;
+  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override;
+
+private:
+  std::shared_ptr<HybridObject> _hybridObject;
+};
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/ByteBufferArrayBuffer.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/ByteBufferArrayBuffer.hpp
new file mode 100644
index 0000000..5f83bed
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/ByteBufferArrayBuffer.hpp
@@ -0,0 +1,52 @@
+//
+//  ByteBufferArrayBuffer.hpp
+//  react-native-nitro
+//
+//  Created by Marc Rousavy on 14.07.24.
+//
+
+#pragma once
+
+#include "ArrayBuffer.hpp"
+#include <fbjni/ByteBuffer.h>
+#include <fbjni/fbjni.h>
+
+namespace margelo::nitro {
+
+using namespace facebook;
+
+/**
+ * Represents an `ArrayBuffer` that holds a `ByteBuffer`.
+ */
+class ByteBufferArrayBuffer final : public ArrayBuffer {
+public:
+  explicit ByteBufferArrayBuffer(const jni::alias_ref<jni::JByteBuffer>& byteBuffer) : _byteBuffer(jni::make_global(byteBuffer)) {
+    _byteBuffer->order(jni::JByteOrder::nativeOrder());
+  }
+
+  ~ByteBufferArrayBuffer() {
+    // Hermes GC can destroy JS objects on a non-JNI Thread.
+    jni::ThreadScope::WithClassLoader([&] { _byteBuffer.reset(); });
+  }
+
+public:
+  [[nodiscard]] uint8_t* data() override {
+    return _byteBuffer->getDirectBytes();
+  }
+  [[nodiscard]] size_t size() const override {
+    return _byteBuffer->getDirectSize();
+  }
+  [[nodiscard]] bool isOwner() const noexcept override {
+    return _byteBuffer != nullptr && _byteBuffer->isDirect();
+  }
+
+public:
+  [[nodiscard]] const jni::global_ref<jni::JByteBuffer>& getBuffer() const {
+    return _byteBuffer;
+  }
+
+private:
+  jni::global_ref<jni::JByteBuffer> _byteBuffer;
+};
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/CachedProp.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/CachedProp.hpp
new file mode 100644
index 0000000..5553968
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/CachedProp.hpp
@@ -0,0 +1,44 @@
+//
+// Created by Marc Rousavy on 30.07.24.
+//
+
+#pragma once
+
+#include "BorrowingReference.hpp"
+#include "JSIConverter.hpp"
+#include "NitroDefines.hpp"
+#include <jsi/jsi.h>
+
+namespace margelo::nitro {
+
+using namespace facebook;
+
+template <typename T>
+struct CachedProp {
+public:
+  T value;
+  BorrowingReference<jsi::Value> jsiValue;
+  bool isDirty = false;
+
+public:
+  bool equals(jsi::Runtime& runtime, const jsi::Value& other) const {
+    if (jsiValue == nullptr) {
+      return false;
+    }
+    return jsi::Value::strictEquals(runtime, *jsiValue, other);
+  }
+
+public:
+  static CachedProp<T> fromRawValue(jsi::Runtime& runtime, const jsi::Value& value, const CachedProp<T>& oldProp) {
+    if (oldProp.equals(runtime, value)) {
+      // jsi::Value hasn't changed - no need to convert it again!
+      return oldProp;
+    }
+    T converted = JSIConverter<T>::fromJSI(runtime, value);
+    JSICacheReference cache = JSICache::getOrCreateCache(runtime);
+    BorrowingReference<jsi::Value> cached = cache.makeShared(jsi::Value(runtime, value));
+    return CachedProp<T>(std::move(converted), std::move(cached), /* isDirty */ true);
+  }
+};
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/CallInvokerDispatcher.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/CallInvokerDispatcher.hpp
new file mode 100644
index 0000000..2f8ccf5
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/CallInvokerDispatcher.hpp
@@ -0,0 +1,38 @@
+//
+// Created by Marc Rousavy on 27.03.24.
+//
+
+#pragma once
+
+#include "Dispatcher.hpp"
+
+// This is react-native specific
+#if __has_include(<ReactCommon/CallInvoker.h>)
+#include <ReactCommon/CallInvoker.h>
+
+namespace margelo::nitro {
+
+using namespace facebook;
+
+/**
+ * A Dispatcher that uses react::CallInvoker for it's implementation
+ */
+class CallInvokerDispatcher final : public Dispatcher {
+public:
+  explicit CallInvokerDispatcher(std::shared_ptr<react::CallInvoker> callInvoker) : _callInvoker(callInvoker) {}
+
+  void runAsync(std::function<void()>&& function) override {
+    _callInvoker->invokeAsync(std::move(function));
+  }
+
+  void runSync(std::function<void()>&& function) override {
+    _callInvoker->invokeSync(std::move(function));
+  }
+
+private:
+  std::shared_ptr<react::CallInvoker> _callInvoker;
+};
+
+} // namespace margelo::nitro
+
+#endif
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/CountTrailingOptionals.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/CountTrailingOptionals.hpp
new file mode 100644
index 0000000..4e98b85
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/CountTrailingOptionals.hpp
@@ -0,0 +1,64 @@
+//
+//  CountTrailingOptionals.hpp
+//  NitroModules
+//
+//  Created by Marc Rousavy on 21.06.24.
+//
+
+#pragma once
+
+#include <optional>
+#include <type_traits>
+
+namespace margelo::nitro {
+
+// Helper template to check if a type is std::optional
+template <typename T>
+struct is_optional : std::false_type {};
+
+template <typename T>
+struct is_optional<std::optional<T>> : std::true_type {};
+
+// Helper template to count trailing optionals
+template <int N = 0, typename... Args>
+struct count_trailing_optionals;
+
+template <>
+struct count_trailing_optionals<> {
+  static constexpr int value = 0;
+};
+
+template <int N, typename Current, typename... Rest>
+struct count_trailing_optionals<N, Current, Rest...> {
+  static constexpr int count_trailing_optionals_impl() {
+    constexpr bool isOptional = is_optional<std::remove_cvref_t<Current>>::value;
+    if constexpr (sizeof...(Rest) == 0) {
+      // end of parameter pack!
+      if constexpr (isOptional) {
+        // last item is an optional, finally return the final number incremented by one.
+        return N + 1;
+      } else {
+        // last item is not an optional, so there are 0 trailing optionals.
+        return 0;
+      }
+    } else {
+      // recursively look into next T, either bump N by one or reset it to 0 if it's not an optional.
+      constexpr int newValue = isOptional ? N + 1 : 0;
+      return count_trailing_optionals<newValue, Rest...>::count_trailing_optionals_impl();
+    }
+  }
+
+  static constexpr int value = count_trailing_optionals_impl();
+};
+
+// Main template to count trailing optionals in Args... pack
+template <typename... Args>
+struct trailing_optionals_count {
+  static constexpr int value = count_trailing_optionals<0, Args...>::value;
+};
+
+// Helper alias
+template <typename... Args>
+constexpr int trailing_optionals_count_v = trailing_optionals_count<std::remove_cvref_t<Args>...>::value;
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/DefaultConstructableObject.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/DefaultConstructableObject.hpp
new file mode 100644
index 0000000..25d162a
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/DefaultConstructableObject.hpp
@@ -0,0 +1,79 @@
+//
+//  DefaultConstructableObject.hpp
+//  react-native-nitro
+//
+//  Created by Marc Rousavy on 11.11.24.
+//
+
+#pragma once
+
+#include "NitroDefines.hpp"
+#include <fbjni/fbjni.h>
+
+namespace margelo::nitro {
+
+using namespace facebook;
+
+template <typename T>
+class DefaultConstructableObject final {
+public:
+  explicit DefaultConstructableObject(const char* javaClassDescriptor) {
+    try {
+      // Find JNI class and default constructor
+      _javaClass = jni::findClassStatic(javaClassDescriptor);
+      _defaultConstructor = _javaClass->getConstructor<T()>();
+    } catch (const jni::JniException& exc) {
+      std::string message = exc.what();
+      std::string descriptor = javaClassDescriptor;
+      std::string className = findClassName(descriptor);
+      if (message.find("ClassNotFoundException")) {
+        // Java class cannot be found
+        throw std::runtime_error(
+            "Couldn't find class `" + descriptor +
+            "`!\n"
+            "- Make sure the class exists in the specified namespace.\n"
+            "- Make sure the class is not stripped. If you are using ProGuard, add `@Keep` and `@DoNotStrip` annotations to `" +
+            className + "`.");
+      } else if (message.find("NoSuchMethodError")) {
+        // Default Constructor cannot be found
+        throw std::runtime_error(
+            "Couldn't find " + className +
+            "'s default constructor!\n"
+            "- If you want to autolink " +
+            className +
+            ", add a default constructor that takes zero arguments.\n"
+            "- If you need arguments to create instances of " +
+            className +
+            ", create a separate HybridObject that acts as a factory for this HybridObject to create instances of it with parameters.\n"
+            "- If you already have a default constructor, make sure it is not being stripped. If you are using ProGuard, add `@Keep` and "
+            "`@DoNotStrip` annotations to the default constructor.");
+      } else {
+        throw;
+      }
+    }
+  }
+
+public:
+  jni::local_ref<T> create() const {
+    // Calls the class's default constructor
+    auto instance = _javaClass->newObject(_defaultConstructor);
+#ifdef NITRO_DEBUG
+    if (instance == nullptr) [[unlikely]] {
+      throw std::runtime_error("Failed to create an instance of \"" + _javaClass->toString() + "\" - the constructor returned null!");
+    }
+#endif
+    return instance;
+  }
+
+private:
+  static std::string findClassName(const std::string& jniDescriptor) {
+    size_t lastSlash = jniDescriptor.rfind('/');
+    return jniDescriptor.substr(lastSlash + 1);
+  }
+
+private:
+  jni::alias_ref<jni::JClass> _javaClass;
+  jni::JConstructor<T()> _defaultConstructor;
+};
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/Dispatcher.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/Dispatcher.hpp
new file mode 100644
index 0000000..dfe3070
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/Dispatcher.hpp
@@ -0,0 +1,83 @@
+//
+// Created by Marc Rousavy on 12.03.24.
+//
+
+#pragma once
+
+#include "NitroDefines.hpp"
+#include "Promise.hpp"
+#include <functional>
+#include <jsi/jsi.h>
+#include <queue>
+#include <unordered_map>
+
+namespace margelo::nitro {
+
+using namespace facebook;
+
+class Dispatcher : public jsi::NativeState {
+public:
+  /**
+   Installs the Dispatcher into the given Runtime.
+   It can be accessed using `getRuntimeGlobalDispatcher` later.
+   */
+  static void installRuntimeGlobalDispatcher(jsi::Runtime& runtime, std::shared_ptr<Dispatcher> dispatcher);
+  /**
+   Gets the global Dispatcher in the given Runtime, or throws an error if not found.
+  */
+  static std::shared_ptr<Dispatcher> getRuntimeGlobalDispatcher(jsi::Runtime& runtime);
+
+private:
+  static jsi::Value getRuntimeGlobalDispatcherHolder(jsi::Runtime& runtime);
+
+public:
+  /**
+   * Run the given void function synchronously on the Thread this Dispatcher is managing.
+   */
+  virtual void runSync(std::function<void()>&& function) = 0;
+
+  /**
+   * Run the given void function asynchronously on the Thread this Dispatcher is managing.
+   */
+  virtual void runAsync(std::function<void()>&& function) = 0;
+
+  /**
+   * Run the given function asynchronously on the Thread this Dispatcher is managing,
+   * and return a `Promise<T>` that will hold the result of the function.
+   */
+  template <typename T>
+  std::shared_ptr<Promise<T>> runAsyncAwaitable(std::function<T()>&& function) {
+    // 1. Create Promise that can be shared between this and dispatcher thread
+    auto promise = Promise<T>::create();
+
+    runAsync([function = std::move(function), promise]() {
+      try {
+        if constexpr (std::is_void_v<T>) {
+          // 4. Call the actual function on the new Thread
+          function();
+          // 5.a. Resolve the Promise if we succeeded
+          promise->resolve();
+        } else {
+          // 4. Call the actual function on the new Thread
+          T result = function();
+          // 5.a. Resolve the Promise if we succeeded
+          promise->resolve(std::move(result));
+        }
+      } catch (...) {
+        // 5.b. Reject the Promise if the call failed
+        promise->reject(std::current_exception());
+      }
+    });
+
+    // 3. Return an open `Promise<T>` that gets resolved later by the dispatcher Thread
+    return promise;
+  }
+
+private:
+  static std::unordered_map<jsi::Runtime * NON_NULL, std::weak_ptr<Dispatcher>> _globalCache;
+
+private:
+  static constexpr auto TAG = "Dispatcher";
+};
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/FastVectorCopy.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/FastVectorCopy.hpp
new file mode 100644
index 0000000..f8c0778
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/FastVectorCopy.hpp
@@ -0,0 +1,45 @@
+//
+//  FastVectorCopy.hpp
+//  NitroModules
+//
+//  Created by Marc Rousavy on 22.09.25.
+//
+
+#pragma once
+
+#include "NitroDefines.hpp"
+#include <span>
+#include <type_traits>
+#include <vector>
+
+namespace margelo::nitro {
+
+/**
+ * Copies `data` into an `std::vector` as fast as possible.
+ *
+ * If the type is trivially copyable (aka if it does not have a copy constructor),
+ * the data will be bulk-memcopied.
+ */
+template <typename T>
+[[deprecated("FastVectorCopy is not safe for Swift - upgrade Nitro!")]]
+std::vector<T> FastVectorCopy(const T* CONTIGUOUS_MEMORY NON_NULL data, size_t size) {
+  assert(data != nullptr && "FastVectoryCopy: data cannot be null!");
+
+  if (size == 0) [[unlikely]] {
+    // It's an empty vector.
+    return std::vector<T>();
+  }
+
+  if constexpr (std::is_trivially_copyable_v<T>) {
+    // FAST: Type does not have a copy constructor - simply memcpy it
+    std::vector<T> vector(size);
+    std::memcpy(vector.data(), data, size * sizeof(T));
+    return vector;
+  } else {
+    // SLOW: Type needs to be iterated to copy-construct it
+    std::span<const T> span(data, size);
+    return std::vector<T>(span.begin(), span.end());
+  }
+}
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/FutureType.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/FutureType.hpp
new file mode 100644
index 0000000..7a282d4
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/FutureType.hpp
@@ -0,0 +1,28 @@
+//
+//  FutureType.hpp
+//  NitroModules
+//
+//  Created by Marc Rousavy on 21.06.24.
+//
+
+#pragma once
+
+#include <future>
+#include <type_traits>
+
+namespace margelo::nitro {
+
+// Gets the `T` in `std::future<T>`.
+template <typename T>
+struct future_type {
+  using type = void;
+};
+template <typename T>
+struct future_type<std::future<T>> {
+  using type = T;
+};
+
+template <typename T>
+using future_type_v = typename future_type<std::remove_reference_t<T>>::type;
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/HardwareBufferArrayBuffer.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/HardwareBufferArrayBuffer.hpp
new file mode 100644
index 0000000..86c307f
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/HardwareBufferArrayBuffer.hpp
@@ -0,0 +1,93 @@
+//
+//  HardwareBufferArrayBuffer.hpp
+//  react-native-nitro
+//
+//  Created by Marc Rousavy on 14.07.24.
+//
+
+#pragma once
+
+#include "ArrayBuffer.hpp"
+#include "JHardwareBufferUtils.hpp"
+#include <android/hardware_buffer.h>
+#include <android/hardware_buffer_jni.h>
+#include <fbjni/ByteBuffer.h>
+#include <fbjni/fbjni.h>
+
+namespace margelo::nitro {
+
+using namespace facebook;
+
+#if __ANDROID_API__ >= 26
+/**
+ * Represents an `ArrayBuffer` that holds a `HardwareBuffer`.
+ */
+class HardwareBufferArrayBuffer final : public ArrayBuffer {
+public:
+  /**
+   * Create a new `HardwareBufferArrayBuffer` instance that wraps the given `HardwareBuffer`.
+   * This constructor will add a +1 retain count on the given `hardwareBuffer` using
+   * `AHardwareBuffer_acquire(...)`, and release it again once it is destructured.
+   */
+  explicit HardwareBufferArrayBuffer(AHardwareBuffer* hardwareBuffer)
+      : _hardwareBuffer(hardwareBuffer), _dataCached(nullptr), _isLocked(false) {
+    AHardwareBuffer_acquire(hardwareBuffer);
+  }
+
+  ~HardwareBufferArrayBuffer() override {
+    // Hermes GC can destroy JS objects on a non-JNI Thread.
+    unlock();
+    jni::ThreadScope::WithClassLoader([&] { AHardwareBuffer_release(_hardwareBuffer); });
+  }
+
+public:
+  /**
+   * Unlocks the HardwareBuffer if it was locked.
+   * Subsequent calls to `data()` will have to lock the buffer again.
+   *
+   * It is a good practice to call this when the buffer is likely not being
+   * read from using this `HardwareBufferArrayBuffer` instance again anytime soon.
+   */
+  void unlock() {
+    if (_isLocked) {
+      AHardwareBuffer_unlock(_hardwareBuffer, nullptr);
+      _isLocked = false;
+    }
+    _dataCached = nullptr;
+  }
+
+public:
+  [[nodiscard]] uint8_t* data() override {
+    if (_isLocked && _dataCached != nullptr) {
+      // We are still locked on the AHardwareBuffer* and have a valid buffer.
+      return _dataCached;
+    }
+    void* buffer;
+    int result = AHardwareBuffer_lock(_hardwareBuffer, AHARDWAREBUFFER_USAGE_CPU_READ_MASK, -1, nullptr, &buffer);
+    if (result != 0) {
+      throw std::runtime_error("Failed to read HardwareBuffer bytes!");
+    }
+    _dataCached = static_cast<uint8_t*>(buffer);
+    _isLocked = true;
+    return _dataCached;
+  }
+  [[nodiscard]] size_t size() const override {
+    return JHardwareBufferUtils::getHardwareBufferSize(_hardwareBuffer);
+  }
+  [[nodiscard]] bool isOwner() const noexcept override {
+    return true;
+  }
+
+public:
+  [[nodiscard]] AHardwareBuffer* getBuffer() const {
+    return _hardwareBuffer;
+  }
+
+private:
+  AHardwareBuffer* _hardwareBuffer;
+  uint8_t* _dataCached;
+  bool _isLocked;
+};
+#endif
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/HybridFunction.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/HybridFunction.hpp
new file mode 100644
index 0000000..4ba42f9
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/HybridFunction.hpp
@@ -0,0 +1,269 @@
+//
+//  HybridFunction.hpp
+//  NitroModules
+//
+//  Created by Marc Rousavy on 07.08.24.
+//
+
+#pragma once
+
+namespace margelo::nitro {
+template <typename T, typename Enable>
+struct JSIConverter;
+} // namespace margelo::nitro
+
+#include "CountTrailingOptionals.hpp"
+#include "InstanceMethod.hpp"
+#include "JSIConverter.hpp"
+#include "NitroDefines.hpp"
+#include "NitroTypeInfo.hpp"
+#include <exception>
+#include <functional>
+#include <jsi/jsi.h>
+#include <memory>
+#include <string>
+#include <type_traits>
+
+namespace margelo::nitro {
+
+using namespace facebook;
+
+/**
+ * Represents the kind of a function - it can be either a normal function ("METHOD"),
+ * or a property ("GETTER" + "SETTER")
+ */
+enum class FunctionKind { METHOD, GETTER, SETTER };
+
+/**
+ * A helper for an `InstanceMethod` that doesn't have a typed return value or arguments, but instead uses raw JSI values.
+ */
+template <typename T>
+using RawInstanceMethod = InstanceMethod<
+    /* instance type */ T,
+    /* return value */ jsi::Value,
+    /* jsi::HostFunction arguments */ jsi::Runtime&, const jsi::Value&, const jsi::Value*, size_t>;
+
+/**
+ * Represents a Hybrid Function.
+ */
+class HybridFunction final {
+private:
+  jsi::HostFunctionType _function;
+  size_t _paramCount;
+  std::string _name;
+
+public:
+  // getters
+  inline const std::string& getName() const {
+    return _name;
+  }
+  inline size_t getParamCount() const {
+    return _paramCount;
+  }
+  inline const jsi::HostFunctionType& getHostFunction() const {
+    return _function;
+  }
+
+public:
+  // functions
+  inline jsi::Function toJSFunction(jsi::Runtime& runtime) const {
+    return jsi::Function::createFromHostFunction(runtime, jsi::PropNameID::forUtf8(runtime, _name), static_cast<unsigned int>(_paramCount),
+                                                 _function);
+  }
+
+private:
+  HybridFunction(jsi::HostFunctionType&& function, size_t paramCount, const std::string& name)
+      : _function(std::move(function)), _paramCount(paramCount), _name(name) {}
+
+public:
+  /**
+   * Create a new `HybridFunction` that can be called from JS.
+   * This performs proper JSI -> C++ conversion using `JSIConverter<T>`,
+   * and assumes that the object this is called on has a proper `this` configured.
+   * The object's `this` needs to be a `NativeState`.
+   */
+  template <typename THybrid, typename ReturnType, typename... Args>
+  static inline HybridFunction createHybridFunction(/* The name of the method */ const std::string& name,
+                                                    /* The method on THybrid */ InstanceMethod<THybrid, ReturnType, Args...> method,
+                                                    /* The type of the method */ FunctionKind kind) {
+    jsi::HostFunctionType hostFunction = [name, method, kind](/* JS Runtime */ jsi::Runtime& runtime,
+                                                              /* HybridObject */ const jsi::Value& thisValue,
+                                                              /* JS arguments */ const jsi::Value* NON_NULL args,
+                                                              /* argument size */ size_t count) -> jsi::Value {
+      // 1. Get actual `HybridObject` instance from `thisValue` (it's stored as `NativeState`)
+      std::shared_ptr<THybrid> hybridInstance = getHybridObjectNativeState<THybrid>(runtime, thisValue, kind, name);
+
+      // 2. Make sure the given arguments match, either with a static size, or with potentially optional arguments size.
+      constexpr size_t optionalArgsCount = trailing_optionals_count_v<Args...>;
+      constexpr size_t maxArgsCount = sizeof...(Args);
+      constexpr size_t minArgsCount = maxArgsCount - optionalArgsCount;
+      bool isWithinArgsRange = (count >= minArgsCount && count <= maxArgsCount);
+      if (!isWithinArgsRange) [[unlikely]] {
+        // invalid amount of arguments passed!
+        std::string funcName = getHybridFuncFullName<THybrid>(kind, name, hybridInstance.get());
+        if constexpr (minArgsCount == maxArgsCount) {
+          // min and max args length is the same, so we don't have any optional parameters. fixed count
+          throw jsi::JSError(runtime, "`" + funcName + "` expected " + std::to_string(maxArgsCount) + " arguments, but received " +
+                                          std::to_string(count) + "!");
+        } else {
+          // min and max args length are different, so we have optional parameters - variable length arguments.
+          throw jsi::JSError(runtime, "`" + funcName + "` expected between " + std::to_string(minArgsCount) + " and " +
+                                          std::to_string(maxArgsCount) + " arguments, but received " + std::to_string(count) + "!");
+        }
+      }
+
+      try {
+        // 3. Actually call the method with JSI values as arguments and return a JSI value again.
+        //    Internally, this method converts the JSI values to C++ values using `JSIConverter<T>`.
+        return callMethod(hybridInstance.get(), method, runtime, args, count, std::index_sequence_for<Args...>{});
+      } catch (const std::exception& exception) {
+        // Some exception was thrown - add method name information and re-throw as `JSError`.
+        std::string funcName = getHybridFuncFullName<THybrid>(kind, name, hybridInstance.get());
+        std::string message = exception.what();
+        throw jsi::JSError(runtime, funcName + ": " + message);
+      } catch (...) {
+        // Some unknown exception was thrown - add method name information and re-throw as `JSError`.
+        std::string funcName = getHybridFuncFullName<THybrid>(kind, name, hybridInstance.get());
+        std::string errorName = TypeInfo::getCurrentExceptionName();
+        throw jsi::JSError(runtime, "`" + funcName + "` threw an unknown " + errorName + " error.");
+      }
+    };
+
+    return HybridFunction(std::move(hostFunction), sizeof...(Args), name);
+  }
+
+  /**
+   * Create a new `HybridFunction` that can be called from JS.
+   * Unlike `createHybridFunction(...)`, this method does **not** perform any argument parsing or size checking.
+   * It is a raw-, untyped JSI method, and the user is expected to manually handle arguments and return values.
+   */
+  template <typename Derived>
+  static inline HybridFunction createRawHybridFunction(/* The name of the raw method */ const std::string& name,
+                                                       /* The number of expected arguments */ size_t expectedArgumentsCount,
+                                                       /* The raw JSI method on the instance */ RawInstanceMethod<Derived> method) {
+    jsi::HostFunctionType hostFunction = [name, method](/* JS Runtime */ jsi::Runtime& runtime,
+                                                        /* HybridObject */ const jsi::Value& thisValue,
+                                                        /* JS arguments */ const jsi::Value* args,
+                                                        /* argument size */ size_t count) -> jsi::Value {
+      // 1. Get actual `HybridObject` instance from `thisValue` (it's stored as `NativeState`)
+      std::shared_ptr<Derived> hybridInstance = getHybridObjectNativeState<Derived>(runtime, thisValue, FunctionKind::METHOD, name);
+
+      // 2. Call the raw JSI method using raw JSI Values. Exceptions are also expected to be handled by the user.
+      Derived* pointer = hybridInstance.get();
+      return (pointer->*method)(runtime, thisValue, args, count);
+    };
+
+    return HybridFunction(std::move(hostFunction), expectedArgumentsCount, name);
+  }
+
+private:
+  /**
+   * Calls the given method on the given instance with the given `jsi::Value` arguments by converting them to the desired target types.
+   * The given method's return value will be converted to a `jsi::Value` again.
+   */
+  template <typename Derived, typename ReturnType, typename... Args, size_t... Is>
+  static inline jsi::Value callMethod(/* The instance to call the method on */ Derived* NON_NULL obj,
+                                      /* The method to call */ InstanceMethod<Derived, ReturnType, Args...> method,
+                                      /* JS Runtime */ jsi::Runtime& runtime,
+                                      /* JS Arguments */ const jsi::Value* NON_NULL args,
+                                      /* JS Arguments count */ size_t argsSize, std::index_sequence<Is...>) {
+    static const jsi::Value defaultValue;
+
+    if constexpr (std::is_void_v<ReturnType>) {
+      // It's a void method.
+      (obj->*method)(JSIConverter<std::decay_t<Args>>::fromJSI(runtime, Is < argsSize ? args[Is] : defaultValue)...);
+      return jsi::Value::undefined();
+    } else {
+      // It's returning some C++ type, we need to convert that to a JSI value now.
+      ReturnType result = (obj->*method)(JSIConverter<std::decay_t<Args>>::fromJSI(runtime, Is < argsSize ? args[Is] : defaultValue)...);
+      return JSIConverter<ReturnType>::toJSI(runtime, std::forward<ReturnType>(result));
+    }
+  }
+
+private:
+  /**
+   * Get the `NativeState` of the given `value`.
+   */
+  template <typename THybrid>
+  static inline std::shared_ptr<THybrid> getHybridObjectNativeState(jsi::Runtime& runtime, const jsi::Value& value,
+                                                                    [[maybe_unused]] FunctionKind funcKind,
+                                                                    [[maybe_unused]] const std::string& funcName) {
+    // 1. Convert jsi::Value to jsi::Object
+#ifdef NITRO_DEBUG
+    if (!value.isObject()) [[unlikely]] {
+      throw jsi::JSError(runtime, "Cannot " + getHybridFuncDebugInfo<THybrid>(funcKind, funcName) +
+                                      " - `this` is not bound! Suggestions:\n"
+                                      "- Did you accidentally destructure the `HybridObject`? (`const { " +
+                                      funcName +
+                                      " } = ...`)\n"
+                                      "- Did you call `dispose()` on the `HybridObject` before?"
+                                      "- Did you accidentally call `" +
+                                      funcName + "` on the prototype directly?");
+    }
+#endif
+    jsi::Object object = value.getObject(runtime);
+
+    // 2. Check if it even has any kind of `NativeState`
+#ifdef NITRO_DEBUG
+    if (!object.hasNativeState(runtime)) [[unlikely]] {
+      throw jsi::JSError(runtime, "Cannot " + getHybridFuncDebugInfo<THybrid>(funcKind, funcName) +
+                                      " - `this` does not have a NativeState! Suggestions:\n"
+                                      "- Did you accidentally destructure the `HybridObject`? (`const { " +
+                                      funcName +
+                                      " } = ...`)\n"
+                                      "- Did you call `dispose()` on the `HybridObject` before?"
+                                      "- Did you accidentally call `" +
+                                      funcName + "` on the prototype directly?");
+    }
+#endif
+
+    // 3. Get `NativeState` from the jsi::Object and check if it is non-null
+    std::shared_ptr<jsi::NativeState> nativeState = object.getNativeState(runtime);
+#ifdef NITRO_DEBUG
+    if (nativeState == nullptr) [[unlikely]] {
+      throw jsi::JSError(runtime, "Cannot " + getHybridFuncDebugInfo<THybrid>(funcKind, funcName) +
+                                      " - `this`'s `NativeState` is `null`, "
+                                      "did you accidentally call `dispose()` on this object?");
+    }
+#endif
+
+    // 4. Try casting it to our desired target type.
+    std::shared_ptr<THybrid> hybridInstance = std::dynamic_pointer_cast<THybrid>(nativeState);
+#ifdef NITRO_DEBUG
+    if (hybridInstance == nullptr) [[unlikely]] {
+      throw jsi::JSError(runtime, "Cannot " + getHybridFuncDebugInfo<THybrid>(funcKind, funcName) +
+                                      " - `this` has a NativeState, but it's the wrong type!");
+    }
+#endif
+    return hybridInstance;
+  }
+
+private:
+  template <typename THybrid>
+  static inline std::string getHybridFuncFullName(FunctionKind kind, const std::string& registrationName,
+                                                  THybrid* NULLABLE hybridInstance = nullptr) {
+    std::string typeName = hybridInstance != nullptr ? hybridInstance->getName() : TypeInfo::getFriendlyTypename<THybrid>(true);
+    switch (kind) {
+      case FunctionKind::METHOD:
+        return typeName + "." + registrationName + "(...)";
+      case FunctionKind::GETTER:
+      case FunctionKind::SETTER:
+        return typeName + "." + registrationName;
+    }
+  }
+  template <typename THybrid>
+  static inline std::string getHybridFuncDebugInfo(FunctionKind kind, const std::string& registrationName,
+                                                   THybrid* NULLABLE hybridInstance = nullptr) {
+    auto funcName = getHybridFuncFullName<THybrid>(kind, registrationName, hybridInstance);
+    switch (kind) {
+      case FunctionKind::METHOD:
+        return "call hybrid function `" + funcName + "`";
+      case FunctionKind::GETTER:
+        return "get hybrid property `" + funcName + "`";
+      case FunctionKind::SETTER:
+        return "set hybrid property `" + funcName + "`";
+    }
+  }
+};
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/HybridNitroModulesProxy.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/HybridNitroModulesProxy.hpp
new file mode 100644
index 0000000..df321d3
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/HybridNitroModulesProxy.hpp
@@ -0,0 +1,52 @@
+//
+//  HybridNitroModulesProxy.hpp
+//  NitroModules
+//
+//  Created by Marc Rousavy on 05.10.24
+//
+
+#pragma once
+
+#include "BoxedHybridObject.hpp"
+#include "HybridObject.hpp"
+#include <memory>
+#include <string>
+
+namespace margelo::nitro {
+
+/**
+ * Represents the entry point for all other HybridObjects.
+ * The flow is as following:
+ * 1. (optional) Install a Dispatcher in `jsi::Runtime` to use async/callbacks.
+ * 2. Create an instance of `HybridNitroModulesProxy`
+ * 3. Pass the object from `.toObject()` it to JS (either install in global, or return somehow)
+ * 4. From JS, you can access methods on this HybridObject to create all other HybridObjects.
+ */
+class HybridNitroModulesProxy final : public HybridObject {
+public:
+  explicit HybridNitroModulesProxy() : HybridObject(TAG) {}
+
+public:
+  void loadHybridMethods() override;
+
+public:
+  // Hybrid Object Registry
+  std::shared_ptr<HybridObject> createHybridObject(const std::string& name);
+  bool hasHybridObject(const std::string& name);
+  std::vector<std::string> getAllHybridObjectNames();
+
+  // Helpers
+  std::shared_ptr<BoxedHybridObject> box(const std::shared_ptr<HybridObject>& hybridObject);
+  std::shared_ptr<HybridObject> updateMemorySize(const std::shared_ptr<HybridObject>& hybridObject);
+  jsi::Value hasNativeState(jsi::Runtime& runtime, const jsi::Value& thisValue, const jsi::Value* args, size_t size);
+  jsi::Value isHybridObject(jsi::Runtime& runtime, const jsi::Value& thisValue, const jsi::Value* args, size_t size);
+
+  // Build Info
+  std::string getBuildType();
+  std::string getVersion();
+
+private:
+  static constexpr auto TAG = "NitroModulesProxy";
+};
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/HybridObject.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/HybridObject.hpp
new file mode 100644
index 0000000..68b6a8b
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/HybridObject.hpp
@@ -0,0 +1,152 @@
+//
+// Created by Marc Rousavy on 21.02.24.
+//
+
+#pragma once
+
+#include "HybridObjectPrototype.hpp"
+
+#include "NitroDefines.hpp"
+#include <jsi/jsi.h>
+#include <memory>
+#include <type_traits>
+
+namespace margelo::nitro {
+
+using namespace facebook;
+
+/**
+ * Represents a C++ object that is exposed to JS.
+ * `HybridObject`s can have native getters and setters, and normal methods.
+ *
+ * To implement a `HybridObject`, simply inherit from this class and override `loadHybridMethods`
+ * to register the given getters, setters or methods.
+ *
+ * The new class can then be passed to JS using the `JSIConverter<HybridObject>`.
+ */
+class HybridObject : public virtual jsi::NativeState, public HybridObjectPrototype, public std::enable_shared_from_this<HybridObject> {
+public:
+  /**
+   * Create a new instance of a `HybridObject`.
+   * The given `name` will be used for logging and stringifying.
+   */
+  explicit HybridObject(const char* NON_NULL name);
+  /**
+   * Called when no more references to the given `HybridObject` exist in both C++ and JS.
+   * JS might keep references for longer, as it is a garbage collected language.
+   */
+  ~HybridObject() override = default;
+  /**
+   * HybridObjects cannot be copied.
+   */
+  HybridObject(const HybridObject& copy) = delete;
+  /**
+   * HybridObjects cannot be moved.
+   */
+  HybridObject(HybridObject&& move) = delete;
+  /**
+   * HybridObjects cannot be default-constructed!
+   * Use this instead;
+   * ```cpp
+   * MyHybridObject(): HybridObject(TAG) {}
+   * ```
+   */
+  HybridObject() {
+    throw std::runtime_error("Cannot default-construct HybridObject! "
+                             "Did you forget to add the `HybridObject(TAG)` base-constructor call to your Hybrid Object's constructor?");
+  }
+
+public:
+  /**
+   * Return the `jsi::Object` that holds this `HybridObject`. (boxed in a `jsi::Value`)
+   * This properly assigns (or creates) the base prototype for this type,
+   * and assigns it's NativeState.
+   * Additionally, this sets the external memory pressure for proper GC memory management.
+   */
+  jsi::Value toObject(jsi::Runtime& runtime);
+
+public:
+  /**
+   * Get the `std::shared_ptr` instance of this HybridObject as it's concrete type.
+   * The HybridObject must be managed inside a `shared_ptr` already, otherwise this will fail.
+   */
+  template <typename Derived>
+  std::shared_ptr<Derived> shared_cast() {
+    return std::dynamic_pointer_cast<Derived>(shared());
+  }
+  /**
+   * Get the `std::shared_ptr` instance of this HybridObject.
+   */
+  virtual std::shared_ptr<HybridObject> shared();
+
+public:
+  /**
+   * Get the HybridObject's name
+   */
+  std::string getName();
+  /**
+   * Compare this HybridObject for reference equality to the other HybridObject.
+   *
+   * While two `jsi::Object`s of the same `HybridObject` might not be equal when compared with `==`,
+   * they might still be the same `HybridObject` - in this case `equals(other)` will return true.
+   */
+  bool equals(const std::shared_ptr<HybridObject>& other);
+  /**
+   * Get a string representation of this `HybridObject` - useful for logging or debugging.
+   */
+  virtual std::string toString();
+  /**
+   * Eagerly- (and manually-) dispose all native resources this `HybridObject` holds.
+   * This method can only be manually called from JS using `dispose()`.
+   *
+   * If this method is never manually called, a `HybridObject` is expected to disposes it's
+   * resources as usual via the object's destructor (`~HybridObject()`, `deinit` or `finalize()`).
+   *
+   * By default, this method does nothing. It can be overridden to perform actual disposing/cleanup
+   * if required.
+   */
+  virtual void dispose() {}
+
+private:
+  /**
+   * The actual `dispose()` function from JS.
+   * This needs to be a raw JSI function as we remove the NativeState here.
+   */
+  jsi::Value disposeRaw(jsi::Runtime& runtime, const jsi::Value& thisArg, const jsi::Value* NON_NULL args, size_t count);
+
+protected:
+  /**
+   * Get the size of any external (heap) allocations this `HybridObject` has made, in bytes.
+   * This will be used to notify the JS GC about memory pressure.
+   */
+  virtual inline size_t getExternalMemorySize() noexcept {
+    return 0;
+  }
+
+protected:
+  /**
+   * Loads all native methods of this `HybridObject` to be exposed to JavaScript.
+   * The base implementation registers a `toString()` method and `name` property.
+   *
+   * Example:
+   *
+   * ```cpp
+   * int User::getAge() {
+   *   return 23;
+   * }
+   *
+   * void User::loadHybridMethods() {
+   *   HybridObject::loadHybridMethods();
+   *   registerHybridMethod("getAge", &User::getAge);
+   * }
+   * ```
+   */
+  virtual void loadHybridMethods() override;
+
+private:
+  static constexpr auto TAG = "HybridObject";
+  const char* NON_NULL _name = TAG;
+  std::unordered_map<jsi::Runtime*, BorrowingReference<jsi::WeakObject>> _objectCache;
+};
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/HybridObjectPrototype.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/HybridObjectPrototype.hpp
new file mode 100644
index 0000000..0397e60
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/HybridObjectPrototype.hpp
@@ -0,0 +1,93 @@
+//
+//  HybridObjectPrototype.hpp
+//  NitroModules
+//
+//  Created by Marc Rousavy on 07.08.24.
+//
+
+#pragma once
+
+#include "BorrowingReference.hpp"
+#include "HybridFunction.hpp"
+#include "NitroDefines.hpp"
+#include "Prototype.hpp"
+#include "PrototypeChain.hpp"
+#include <functional>
+#include <jsi/jsi.h>
+#include <memory>
+#include <mutex>
+#include <string>
+#include <type_traits>
+
+namespace margelo::nitro {
+
+using namespace facebook;
+
+/**
+ * Represents a Hybrid Object's prototype.
+ * The prototype should be cached per Runtime, and can be assigned to multiple jsi::Objects.
+ * When assigned to a jsi::Object, all methods of this prototype can be called on that jsi::Object,
+ * as long as it has a valid NativeState (`this`).
+ */
+class HybridObjectPrototype {
+private:
+  PrototypeChain _prototypeChain;
+  bool _didLoadMethods = false;
+  static constexpr auto TAG = "HybridObjectPrototype";
+
+public:
+  HybridObjectPrototype() {}
+
+public:
+  /**
+   * Get a fully initialized jsi::Object that represents this prototype to JS.
+   * The result of this value will be cached per Runtime, so it's safe to call this often.
+   */
+  jsi::Value getPrototype(jsi::Runtime& runtime);
+
+private:
+  static jsi::Value createPrototype(jsi::Runtime& runtime, const std::shared_ptr<Prototype>& prototype);
+  using PrototypeCache = std::unordered_map<NativeInstanceId, BorrowingReference<jsi::Object>>;
+  static std::unordered_map<jsi::Runtime * NON_NULL, PrototypeCache> _prototypeCache;
+
+protected:
+  /**
+   * Loads all Hybrid Methods that will be initialized in this Prototype.
+   * This will only be called once for the first time the Prototype will be created,
+   * so don't conditionally register methods.
+   */
+  virtual void loadHybridMethods() = 0;
+
+private:
+  /**
+   * Ensures that all Hybrid Methods, Getters and Setters are initialized by calling loadHybridMethods().
+   */
+  inline void ensureInitialized() {
+    if (!_didLoadMethods) [[unlikely]] {
+      // lazy-load all exposed methods
+      loadHybridMethods();
+      _didLoadMethods = true;
+    }
+  }
+
+protected:
+  using RegisterFn = void (*NON_NULL)(Prototype&);
+  /**
+   * Registers the given methods inside the Hybrid Object's prototype.
+   *
+   * For subsequent HybridObjects of the same type, `registerFunc` will not be called again, as the
+   * prototype will already be known and cached.
+   * **Do not conditionally register hybrid methods, getters or setter!**
+   */
+  template <typename Derived>
+  inline void registerHybrids(Derived* NON_NULL /* this */, RegisterFn registerFunc) {
+    const std::shared_ptr<Prototype>& prototype = _prototypeChain.extendPrototype<Derived>();
+
+    if (!prototype->hasHybrids()) {
+      // The `Prototype` does not have any methods or properties registered yet - so do it now
+      registerFunc(*prototype);
+    }
+  }
+};
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/HybridObjectRegistry.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/HybridObjectRegistry.hpp
new file mode 100644
index 0000000..3c4b82d
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/HybridObjectRegistry.hpp
@@ -0,0 +1,53 @@
+//
+//  HybridObjectRegistry.hpp
+//  react-native-nitro
+//
+//  Created by Marc Rousavy on 22.07.24.
+//
+
+#pragma once
+
+#include "HybridObject.hpp"
+#include <functional>
+#include <string>
+
+namespace margelo::nitro {
+
+/**
+ * A registry that holds initializers for HybridObjects.
+ * This will be used to initialize them from JS using `NitroModules.createHybridObject<T>(name)`.
+ */
+class HybridObjectRegistry {
+public:
+  HybridObjectRegistry() = delete;
+
+public:
+  using HybridObjectConstructorFn = std::function<std::shared_ptr<HybridObject>()>;
+
+public:
+  /**
+   * Registers the given HybridObject in the `HybridObjectRegistry`.
+   * It will be uniquely identified via it's `hybridObjectName`, and can be initialized from
+   * JS using `NitroModules.createHybridObject<T>(name)` - which will call the `constructorFn` here.
+   */
+  static void registerHybridObjectConstructor(const std::string& hybridObjectName, HybridObjectConstructorFn&& constructorFn);
+
+  /**
+   * Unregisters a Hybrid Object with the given `hybridObjectName`.
+   * It is recommended to not use this method, as this makes HybridObject constructors unpredictable from JS.
+   */
+  static void unregisterHybridObjectConstructor(const std::string& hybridObjectName);
+
+  static std::shared_ptr<HybridObject> createHybridObject(const std::string& hybridObjectName);
+  static bool hasHybridObject(const std::string& hybridObjectName);
+  static std::vector<std::string> getAllHybridObjectNames();
+
+private:
+  static std::unordered_map<std::string, HybridObjectConstructorFn>& getRegistry();
+  static std::string getAllRegisteredHybridObjectNamesToString();
+
+private:
+  static constexpr auto TAG = "HybridObjectRegistry";
+};
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/InstallNitro.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/InstallNitro.hpp
new file mode 100644
index 0000000..7abbdcb
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/InstallNitro.hpp
@@ -0,0 +1,41 @@
+//
+//  InstallNitro.hpp
+//  NitroModules
+//
+//  Created by Marc Rousavy on 05.10.24
+//
+
+#pragma once
+
+#include "Dispatcher.hpp"
+#include <jsi/jsi.h>
+#include <memory>
+
+namespace margelo::nitro {
+
+/**
+ * Installs Nitro into the given JS `runtime`.
+ * This will create `global.NitroModulesProxy`, Nitro's entry-point,
+ * which can be used to create all registered HybridObjects from JS.
+ *
+ * Also registers the given `dispatcher` which allows using callbacks,
+ * and async code (Promises).
+ * The `dispatcher` needs to implement `runAsync`/`runSync` to run
+ * methods on whatever Thread can safely access `runtime`.
+ * In a non-thread-safe Runtime, it needs to be a single Thread (e.g.
+ * React's `CallInvoker`), but in a thread-safe Runtime it might just be
+ * an implementation that runs the method directly.
+ */
+void install(jsi::Runtime& runtime, std::shared_ptr<Dispatcher> dispatcher);
+
+/**
+ * Installs Nitro into the given JS `runtime`.
+ * This will create `global.NitroModulesProxy`, Nitro's entry-point,
+ * which can be used to create all registered HybridObjects from JS.
+ *
+ * No `Dispatcher` will be installed, meaning Nitro can only use synchronous
+ * methods.
+ */
+void install(jsi::Runtime& runtime);
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/InstanceMethod.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/InstanceMethod.hpp
new file mode 100644
index 0000000..e3f5a46
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/InstanceMethod.hpp
@@ -0,0 +1,23 @@
+//
+//  InstanceMethod.hpp
+//  NitroModules
+//
+//  Created by Marc Rousavy on 25.09.25.
+//
+
+#pragma once
+
+#include "NitroDefines.hpp"
+
+namespace margelo::nitro {
+
+/**
+ * Represents a Function pointer to an instance method of the given class.
+ * For example:
+ * `InstanceMethod<std::string, size_t>` could point to `size_t std::string::length()`
+ * `InstanceMethod<std::vector<int>, void, int>` could point to `void std::vector<int>::push_back(int)`
+ */
+template <typename T, typename ReturnType, typename... Args>
+using InstanceMethod = ReturnType (T::*NON_NULL)(Args...);
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/IsSharedPtrTo.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/IsSharedPtrTo.hpp
new file mode 100644
index 0000000..9ba0987
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/IsSharedPtrTo.hpp
@@ -0,0 +1,27 @@
+//
+//  IsSharedPtrTo.hpp
+//  NitroModules
+//
+//  Created by Marc Rousavy on 21.06.24.
+//
+
+#pragma once
+
+#include <type_traits>
+
+namespace margelo::nitro {
+
+using namespace facebook;
+
+// Returns whether the given type T is a shared_ptr to type P.
+template <typename T, typename P>
+struct is_shared_ptr_to : std::false_type {};
+
+template <typename T, typename P>
+struct is_shared_ptr_to<std::shared_ptr<T>, P> : std::is_base_of<typename std::remove_cv<typename std::remove_reference<P>::type>::type,
+                                                                 typename std::remove_cv<typename std::remove_reference<T>::type>::type> {};
+
+template <typename T, typename P>
+constexpr bool is_shared_ptr_to_v = is_shared_ptr_to<T, P>::value;
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JAnyMap.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JAnyMap.hpp
new file mode 100644
index 0000000..8a12f45
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JAnyMap.hpp
@@ -0,0 +1,232 @@
+//
+//  JAnyMap.hpp
+//  react-native-nitro
+//
+//  Created by Marc Rousavy on 14.07.24.
+//
+
+#pragma once
+
+#include "AnyMap.hpp"
+#include "JAnyValue.hpp"
+#include <fbjni/fbjni.h>
+
+namespace margelo::nitro {
+
+using namespace facebook;
+
+/**
+ * Represents an `AnyMap` implemented in Java.
+ */
+class JAnyMap final : public jni::HybridClass<JAnyMap> {
+public:
+  static auto constexpr kJavaDescriptor = "Lcom/margelo/nitro/core/AnyMap;";
+
+public:
+  /**
+   * Create a new, empty `AnyMap` from Java.
+   */
+  static jni::local_ref<JAnyMap::jhybriddata> initHybrid(jni::alias_ref<jhybridobject>) {
+    return makeCxxInstance();
+  }
+  /**
+   * Create a new, empty `AnyMap` with the given preallocated size from Java.
+   */
+  static jni::local_ref<JAnyMap::jhybriddata> initHybridPreallocatedSize(jni::alias_ref<jhybridobject>, jint preallocatedSize) {
+    return makeCxxInstance(preallocatedSize);
+  }
+  /**
+   * Create a new `JAnyMap` from an existing `AnyMap`.
+   */
+  static jni::local_ref<JAnyMap::javaobject> create(const std::shared_ptr<AnyMap>& map) {
+    return newObjectCxxArgs(map);
+  }
+
+private:
+  JAnyMap() {
+    _map = AnyMap::make();
+  }
+  JAnyMap(jint preallocatedSize) {
+    _map = AnyMap::make(static_cast<size_t>(preallocatedSize));
+  }
+  explicit JAnyMap(const std::shared_ptr<AnyMap>& map) : _map(map) {}
+
+protected:
+  bool contains(const std::string& key) {
+    return _map->contains(key);
+  }
+  void remove(const std::string& key) {
+    _map->remove(key);
+  }
+  void clear() {
+    _map->clear();
+  }
+  jni::local_ref<jni::JArrayClass<jni::JString>> getAllKeys() {
+    auto& map = _map->getMap();
+    auto array = jni::JArrayClass<jni::JString>::newArray(map.size());
+    size_t index = 0;
+    for (const auto& pair : map) {
+      auto jKey = jni::make_jstring(pair.first);
+      array->setElement(index, *jKey);
+      index++;
+    }
+    return array;
+  }
+
+protected:
+  bool isNull(const std::string& key) {
+    return _map->isNull(key);
+  }
+  bool isDouble(const std::string& key) {
+    return _map->isDouble(key);
+  }
+  bool isBoolean(const std::string& key) {
+    return _map->isBoolean(key);
+  }
+  bool isBigInt(const std::string& key) {
+    return _map->isBigInt(key);
+  }
+  bool isString(const std::string& key) {
+    return _map->isString(key);
+  }
+  bool isArray(const std::string& key) {
+    return _map->isArray(key);
+  }
+  bool isObject(const std::string& key) {
+    return _map->isObject(key);
+  }
+
+protected:
+  double getDouble(const std::string& key) {
+    return _map->getDouble(key);
+  }
+  bool getBoolean(const std::string& key) {
+    return _map->getBoolean(key);
+  }
+  int64_t getBigInt(const std::string& key) {
+    return _map->getBigInt(key);
+  }
+  std::string getString(const std::string& key) {
+    return _map->getString(key);
+  }
+  jni::local_ref<JAnyArray> getAnyArray(const std::string& key) {
+    const auto& vector = _map->getArray(key);
+    auto javaArray = jni::JArrayClass<JAnyValue::javaobject>::newArray(vector.size());
+    for (size_t i = 0; i < vector.size(); i++) {
+      auto value = JAnyValue::create(vector[i]);
+      javaArray->setElement(i, value.get());
+    }
+    return javaArray;
+  }
+  jni::local_ref<JAnyObject> getAnyObject(const std::string& key) {
+    const auto& map = _map->getObject(key);
+    auto javaMap = jni::JHashMap<jni::JString, JAnyValue::javaobject>::create(map.size());
+    for (const auto& entry : map) {
+      auto string = jni::make_jstring(entry.first);
+      auto value = JAnyValue::create(entry.second);
+      javaMap->put(string, value);
+    }
+    return javaMap;
+  }
+  jni::local_ref<JAnyValue::javaobject> getAnyValue(const std::string& key) {
+    const auto& any = _map->getAny(key);
+    return JAnyValue::create(any);
+  }
+
+protected:
+  void setNull(const std::string& key) {
+    _map->setNull(key);
+  }
+  void setDouble(const std::string& key, double value) {
+    _map->setDouble(key, value);
+  }
+  void setBoolean(const std::string& key, bool value) {
+    _map->setBoolean(key, value);
+  }
+  void setBigInt(const std::string& key, int64_t value) {
+    _map->setBigInt(key, value);
+  }
+  void setString(const std::string& key, const std::string& value) {
+    _map->setString(key, value);
+  }
+  void setAnyArray(const std::string& key, jni::alias_ref<JAnyArray> value) {
+    std::vector<AnyValue> vector;
+    size_t size = value->size();
+    vector.reserve(size);
+    for (size_t i = 0; i < size; i++) {
+      auto anyValue = value->getElement(i);
+      vector.push_back(anyValue->cthis()->getValue());
+    }
+    _map->setArray(key, vector);
+  }
+  void setAnyObject(const std::string& key, const jni::alias_ref<JAnyObject>& value) {
+    std::unordered_map<std::string, AnyValue> map;
+    map.reserve(value->size());
+    for (const auto& entry : *value) {
+      map.emplace(entry.first->toStdString(), entry.second->cthis()->getValue());
+    }
+    _map->setObject(key, map);
+  }
+  void setAnyValue(const std::string& key, const jni::alias_ref<JAnyValue::javaobject>& value) {
+    _map->setAny(key, value->cthis()->getValue());
+  }
+
+protected:
+  void merge(jni::alias_ref<JAnyMap::javaobject> other) {
+    _map->merge(other->cthis()->_map);
+  }
+
+public:
+  [[nodiscard]]
+  std::shared_ptr<AnyMap> getMap() const {
+    return _map;
+  }
+
+private:
+  friend HybridBase;
+  using HybridBase::HybridBase;
+  std::shared_ptr<AnyMap> _map;
+
+public:
+  static void registerNatives() {
+    registerHybrid({
+        // init
+        makeNativeMethod("initHybrid", JAnyMap::initHybrid),
+        makeNativeMethod("initHybrid", JAnyMap::initHybridPreallocatedSize),
+        // helpers
+        makeNativeMethod("contains", JAnyMap::contains),
+        makeNativeMethod("remove", JAnyMap::remove),
+        makeNativeMethod("clear", JAnyMap::clear),
+        makeNativeMethod("getAllKeys", JAnyMap::getAllKeys),
+        // is
+        makeNativeMethod("isNull", JAnyMap::isNull),
+        makeNativeMethod("isDouble", JAnyMap::isDouble),
+        makeNativeMethod("isBoolean", JAnyMap::isBoolean),
+        makeNativeMethod("isBigInt", JAnyMap::isBigInt),
+        makeNativeMethod("isString", JAnyMap::isString),
+        makeNativeMethod("isArray", JAnyMap::isArray),
+        makeNativeMethod("isObject", JAnyMap::isObject),
+        // get
+        makeNativeMethod("getDouble", JAnyMap::getDouble),
+        makeNativeMethod("getBoolean", JAnyMap::getBoolean),
+        makeNativeMethod("getBigInt", JAnyMap::getBigInt),
+        makeNativeMethod("getString", JAnyMap::getString),
+        makeNativeMethod("getAnyArray", JAnyMap::getAnyArray),
+        makeNativeMethod("getAnyObject", JAnyMap::getAnyObject),
+        makeNativeMethod("getAnyValue", JAnyMap::getAnyValue),
+        // set
+        makeNativeMethod("setNull", JAnyMap::setNull),
+        makeNativeMethod("setDouble", JAnyMap::setDouble),
+        makeNativeMethod("setBoolean", JAnyMap::setBoolean),
+        makeNativeMethod("setBigInt", JAnyMap::setBigInt),
+        makeNativeMethod("setString", JAnyMap::setString),
+        makeNativeMethod("setAnyArray", JAnyMap::setAnyArray),
+        makeNativeMethod("setAnyObject", JAnyMap::setAnyObject),
+        makeNativeMethod("setAnyValue", JAnyMap::setAnyValue),
+        // merge
+        makeNativeMethod("merge", JAnyMap::merge),
+    });
+  }
+};
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JAnyValue.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JAnyValue.hpp
new file mode 100644
index 0000000..82f50db
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JAnyValue.hpp
@@ -0,0 +1,191 @@
+//
+//  JAnyMap.hpp
+//  react-native-nitro
+//
+//  Created by Marc Rousavy on 14.07.24.
+//
+
+#pragma once
+
+#include "AnyMap.hpp"
+#include <fbjni/fbjni.h>
+
+namespace margelo::nitro {
+
+using namespace facebook;
+
+/**
+ * Represents an `AnyValue` (variant) implemented in Java.
+ */
+class JAnyValue final : public jni::HybridClass<JAnyValue> {
+public:
+  static auto constexpr kJavaDescriptor = "Lcom/margelo/nitro/core/AnyValue;";
+
+  /**
+   * Represents an `Array<AnyValue>`
+   */
+  using JAnyArray = jni::JArrayClass<JAnyValue::javaobject>;
+  /**
+   * Represents a `Map<String, AnyValue>`
+   */
+  using JAnyObject = jni::JMap<jni::JString, JAnyValue::javaobject>;
+
+public:
+  /**
+   * Create a new `JAnyValue` from an existing `AnyValue`.
+   */
+  static jni::local_ref<JAnyValue::javaobject> create(AnyValue&& value) {
+    return newObjectCxxArgs(std::move(value));
+  }
+  static jni::local_ref<JAnyValue::javaobject> create(const AnyValue& value) {
+    return newObjectCxxArgs(value);
+  }
+
+protected:
+  static jni::local_ref<JAnyValue::jhybriddata> initHybridNull(jni::alias_ref<jhybridobject>) {
+    return makeCxxInstance(/* null */);
+  }
+  static jni::local_ref<JAnyValue::jhybriddata> initHybridDouble(jni::alias_ref<jhybridobject>, double value) {
+    return makeCxxInstance(value);
+  }
+  static jni::local_ref<JAnyValue::jhybriddata> initHybridBoolean(jni::alias_ref<jhybridobject>, bool value) {
+    return makeCxxInstance(value);
+  }
+  static jni::local_ref<JAnyValue::jhybriddata> initHybridLong(jni::alias_ref<jhybridobject>, int64_t value) {
+    return makeCxxInstance(value);
+  }
+  static jni::local_ref<JAnyValue::jhybriddata> initHybridString(jni::alias_ref<jhybridobject>, const std::string& value) {
+    return makeCxxInstance(value);
+  }
+  static jni::local_ref<JAnyValue::jhybriddata> initHybridAnyArray(jni::alias_ref<jhybridobject>, jni::alias_ref<JAnyArray> value) {
+    std::vector<AnyValue> vector;
+    size_t size = value->size();
+    vector.reserve(size);
+    for (size_t i = 0; i < size; i++) {
+      auto anyValue = value->getElement(i);
+      vector.push_back(anyValue->cthis()->getValue());
+    }
+    return makeCxxInstance(std::move(vector));
+  }
+  static jni::local_ref<JAnyValue::jhybriddata> initHybridAnyObject(jni::alias_ref<jhybridobject>, jni::alias_ref<JAnyObject> value) {
+    std::unordered_map<std::string, AnyValue> map;
+    map.reserve(value->size());
+    for (const auto& entry : *value) {
+      map.emplace(entry.first->toStdString(), entry.second->cthis()->getValue());
+    }
+    return makeCxxInstance(std::move(map));
+  }
+
+private:
+  // Java initializers
+  explicit JAnyValue(NullType null) : _value(null) {}
+  explicit JAnyValue(double value) : _value(value) {}
+  explicit JAnyValue(bool value) : _value(value) {}
+  explicit JAnyValue(int64_t value) : _value(value) {}
+  explicit JAnyValue(const std::string& value) : _value(value) {}
+  explicit JAnyValue(AnyArray&& value) : _value(std::move(value)) {}
+  explicit JAnyValue(AnyObject&& value) : _value(std::move(value)) {}
+  // C++ initializers
+  explicit JAnyValue(const AnyValue& value) : _value(value) {}
+  explicit JAnyValue(AnyValue&& value) : _value(std::move(value)) {}
+
+protected:
+  bool isNull() {
+    return std::holds_alternative<NullType>(_value);
+  }
+  bool isDouble() {
+    return std::holds_alternative<double>(_value);
+  }
+  bool isBoolean() {
+    return std::holds_alternative<bool>(_value);
+  }
+  bool isBigInt() {
+    return std::holds_alternative<int64_t>(_value);
+  }
+  bool isString() {
+    return std::holds_alternative<std::string>(_value);
+  }
+  bool isAnyArray() {
+    return std::holds_alternative<AnyArray>(_value);
+  }
+  bool isAnyObject() {
+    return std::holds_alternative<AnyObject>(_value);
+  }
+
+protected:
+  double asDouble() {
+    return std::get<double>(_value);
+  }
+  bool asBoolean() {
+    return std::get<bool>(_value);
+  }
+  int64_t asBigInt() {
+    return std::get<int64_t>(_value);
+  }
+  std::string asString() {
+    return std::get<std::string>(_value);
+  }
+  jni::local_ref<JAnyArray> asAnyArray() {
+    auto vector = std::get<AnyArray>(_value);
+    auto javaArray = jni::JArrayClass<JAnyValue::javaobject>::newArray(vector.size());
+    for (size_t i = 0; i < vector.size(); i++) {
+      auto value = JAnyValue::create(vector[i]);
+      javaArray->setElement(i, value.get());
+    }
+    return javaArray;
+  }
+  jni::local_ref<JAnyObject> asAnyObject() {
+    auto map = std::get<AnyObject>(_value);
+    auto javaMap = jni::JHashMap<jni::JString, JAnyValue::javaobject>::create(map.size());
+    for (const auto& entry : map) {
+      auto key = jni::make_jstring(entry.first);
+      auto value = JAnyValue::create(entry.second);
+      javaMap->put(key, value);
+    }
+    return javaMap;
+  }
+
+public:
+  [[nodiscard]] const AnyValue& getValue() const noexcept {
+    return _value;
+  }
+
+private:
+  friend HybridBase;
+  using HybridBase::HybridBase;
+  AnyValue _value;
+
+public:
+  static void registerNatives() {
+    registerHybrid({
+        // init
+        makeNativeMethod("initHybrid", JAnyValue::initHybridNull),
+        makeNativeMethod("initHybrid", JAnyValue::initHybridDouble),
+        makeNativeMethod("initHybrid", JAnyValue::initHybridBoolean),
+        makeNativeMethod("initHybrid", JAnyValue::initHybridLong),
+        makeNativeMethod("initHybrid", JAnyValue::initHybridString),
+        makeNativeMethod("initHybrid", JAnyValue::initHybridAnyArray),
+        makeNativeMethod("initHybrid", JAnyValue::initHybridAnyObject),
+        // is
+        makeNativeMethod("isNull", JAnyValue::isNull),
+        makeNativeMethod("isDouble", JAnyValue::isDouble),
+        makeNativeMethod("isBoolean", JAnyValue::isBoolean),
+        makeNativeMethod("isBigInt", JAnyValue::isBigInt),
+        makeNativeMethod("isString", JAnyValue::isString),
+        makeNativeMethod("isAnyArray", JAnyValue::isAnyArray),
+        makeNativeMethod("isAnyObject", JAnyValue::isAnyObject),
+        // get
+        makeNativeMethod("asDouble", JAnyValue::asDouble),
+        makeNativeMethod("asBoolean", JAnyValue::asBoolean),
+        makeNativeMethod("asBigInt", JAnyValue::asBigInt),
+        makeNativeMethod("asString", JAnyValue::asString),
+        makeNativeMethod("asAnyArray", JAnyValue::asAnyArray),
+        makeNativeMethod("asAnyObject", JAnyValue::asAnyObject),
+    });
+  }
+};
+
+using JAnyArray = JAnyValue::JAnyArray;
+using JAnyObject = JAnyValue::JAnyObject;
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JArrayBuffer.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JArrayBuffer.hpp
new file mode 100644
index 0000000..c250c0c
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JArrayBuffer.hpp
@@ -0,0 +1,187 @@
+//
+//  JArrayBuffer.hpp
+//  react-native-nitro
+//
+//  Created by Marc Rousavy on 14.07.24.
+//
+
+#pragma once
+
+#include "ArrayBuffer.hpp"
+#include "ByteBufferArrayBuffer.hpp"
+#include "HardwareBufferArrayBuffer.hpp"
+#include <android/hardware_buffer.h>
+#include <android/hardware_buffer_jni.h>
+#include <fbjni/ByteBuffer.h>
+#include <fbjni/fbjni.h>
+#include <functional>
+#include <utility>
+
+namespace margelo::nitro {
+
+using namespace facebook;
+
+/**
+ * Represents a `ArrayBuffer` that can either hold a `ByteBuffer` (owning),
+ * or unknown/foreign memory, potentially from JS (non-owning).
+ */
+class JArrayBuffer final : public jni::HybridClass<JArrayBuffer> {
+public:
+  static auto constexpr kJavaDescriptor = "Lcom/margelo/nitro/core/ArrayBuffer;";
+
+public:
+  /**
+   * Create a new `JArrayBuffer` that wraps the given ArrayBuffer.
+   */
+  static jni::local_ref<JArrayBuffer::javaobject> wrap(const std::shared_ptr<ArrayBuffer>& arrayBuffer) {
+    return newObjectCxxArgs(arrayBuffer);
+  }
+
+public:
+  /**
+   * Create a new `JArrayBuffer` that wraps the given `ByteBuffer` from Java.
+   */
+  static jni::local_ref<JArrayBuffer::jhybriddata> initHybridByteBuffer(jni::alias_ref<jhybridobject>,
+                                                                        jni::alias_ref<jni::JByteBuffer> buffer) {
+    return makeCxxInstance(buffer);
+  }
+  /**
+   * Create a new `JArrayBuffer` that wraps the given `HardwareBuffer` from Java.
+   */
+  static jni::local_ref<JArrayBuffer::jhybriddata>
+  initHybridHardwareBuffer(jni::alias_ref<jhybridobject>, [[maybe_unused]] jni::alias_ref<jni::JObject> boxedHardwareBuffer) {
+#if __ANDROID_API__ >= 26
+    // Cast jobject* to AHardwareBuffer*. It has a retain count of 0 which will be retained in `HardwareBufferArrayBuffer(..)`.
+    AHardwareBuffer* hardwareBuffer = AHardwareBuffer_fromHardwareBuffer(jni::Environment::current(), boxedHardwareBuffer.get());
+    return makeCxxInstance(hardwareBuffer);
+#else
+    throw std::runtime_error("ArrayBuffer(HardwareBuffer) requires NDK API 26 or above! (minSdk >= 26)");
+#endif
+  }
+
+public:
+  /**
+   * Get whether the `ArrayBuffer` is holding data from a `ByteBuffer`.
+   */
+  bool getIsByteBuffer() {
+    auto byteBufferArrayBuffer = std::dynamic_pointer_cast<ByteBufferArrayBuffer>(_arrayBuffer);
+    return byteBufferArrayBuffer != nullptr;
+  }
+
+  /**
+   * Get whether the `ArrayBuffer` is holding data from a `HardwareBuffer`.
+   */
+  bool getIsHardwareBuffer() {
+#if __ANDROID_API__ >= 26
+    auto hardwareBufferArrayBuffer = std::dynamic_pointer_cast<HardwareBufferArrayBuffer>(_arrayBuffer);
+    return hardwareBufferArrayBuffer != nullptr;
+#else
+    return false;
+#endif
+  }
+
+  /**
+   * Get whether the `ArrayBuffer` is owning the data and can safely hold onto it longer.
+   */
+  bool getIsOwner() {
+    return _arrayBuffer->isOwner();
+  }
+
+  /**
+   * Get the `ArrayBuffer`'s data as a `ByteBuffer`.
+   *
+   * - If the `ArrayBuffer` was created from a `ByteBuffer` (`isByteBuffer()`), this returns
+   * a reference to the original `ByteBuffer`, which is safe to be kept in memory for longer.
+   * - If the `ArrayBuffer` was created elsewhere (either in JS, or in C++), it does not have a
+   * `ByteBuffer`. In this case, `getBuffer()` will **copy** the data into a new `ByteBuffer` if
+   * `copyIfNeeded` is `true`, and **wrap** the data into a new `ByteBuffer` if `copyIfNeeded` is false.
+   */
+  [[nodiscard]] jni::local_ref<jni::JByteBuffer> getByteBuffer(bool copyIfNeeded) {
+    auto byteBufferArrayBuffer = std::dynamic_pointer_cast<ByteBufferArrayBuffer>(_arrayBuffer);
+    if (byteBufferArrayBuffer != nullptr) {
+      // It is a `ByteBufferArrayBuffer`, which has a `ByteBuffer` underneath!
+      return jni::make_local(byteBufferArrayBuffer->getBuffer());
+    } else {
+      // It is a different kind of `ArrayBuffer`, we need to copy or wrap the data.
+      size_t size = _arrayBuffer->size();
+      if (copyIfNeeded) {
+        auto buffer = jni::JByteBuffer::allocateDirect(size);
+        buffer->order(jni::JByteOrder::nativeOrder());
+        memcpy(buffer->getDirectAddress(), _arrayBuffer->data(), size);
+        return buffer;
+      } else {
+        auto buffer = jni::JByteBuffer::wrapBytes(_arrayBuffer->data(), size);
+        buffer->order(jni::JByteOrder::nativeOrder());
+        return buffer;
+      }
+    }
+  }
+
+  [[nodiscard]] jni::local_ref<jni::JObject> getHardwareBufferBoxed() {
+#if __ANDROID_API__ >= 26
+    AHardwareBuffer* buffer = getHardwareBuffer();
+    jobject boxed = AHardwareBuffer_toHardwareBuffer(jni::Environment::current(), buffer);
+    return jni::make_local(boxed);
+#else
+    throw std::runtime_error("ArrayBuffer(HardwareBuffer) requires NDK API 26 or above! (minSdk >= 26)");
+#endif
+  }
+
+  int getBufferSize() {
+    return static_cast<int>(_arrayBuffer->size());
+  }
+
+public:
+  /**
+   * Get the underlying `ArrayBuffer`.
+   */
+  [[nodiscard]] std::shared_ptr<ArrayBuffer> getArrayBuffer() const {
+    return _arrayBuffer;
+  }
+  /**
+   * Get the underlying `HardwareBuffer` if it has one.
+   * This method will throw if this `ArrayBuffer` was not created with a `HardwareBuffer`.
+   */
+  [[nodiscard]] AHardwareBuffer* getHardwareBuffer() const {
+#if __ANDROID_API__ >= 26
+    auto hardwareBufferArrayBuffer = std::dynamic_pointer_cast<HardwareBufferArrayBuffer>(_arrayBuffer);
+    if (hardwareBufferArrayBuffer != nullptr) {
+      return hardwareBufferArrayBuffer->getBuffer();
+    } else {
+      throw std::runtime_error("The underlying buffer is not a HardwareBuffer!");
+    }
+#else
+    throw std::runtime_error("ArrayBuffer(HardwareBuffer) requires NDK API 26 or above! (minSdk >= 26)");
+#endif
+  }
+
+private:
+  explicit JArrayBuffer(const std::shared_ptr<ArrayBuffer>& arrayBuffer) : _arrayBuffer(arrayBuffer) {}
+  explicit JArrayBuffer(const jni::alias_ref<jni::JByteBuffer>& byteBuffer) {
+    _arrayBuffer = std::make_shared<ByteBufferArrayBuffer>(byteBuffer);
+  }
+
+#if __ANDROID_API__ >= 26
+  explicit JArrayBuffer(AHardwareBuffer* /* 0 retain */ hardwareBuffer) {
+    _arrayBuffer = std::make_shared<HardwareBufferArrayBuffer>(hardwareBuffer);
+  }
+#endif
+
+private:
+  friend HybridBase;
+  using HybridBase::HybridBase;
+  std::shared_ptr<ArrayBuffer> _arrayBuffer;
+
+public:
+  static void registerNatives() {
+    registerHybrid(
+        {makeNativeMethod("initHybrid", JArrayBuffer::initHybridByteBuffer),
+         makeNativeMethod("initHybridBoxedHardwareBuffer", JArrayBuffer::initHybridHardwareBuffer),
+         makeNativeMethod("getByteBuffer", JArrayBuffer::getByteBuffer), makeNativeMethod("getIsByteBuffer", JArrayBuffer::getIsByteBuffer),
+         makeNativeMethod("getHardwareBufferBoxed", JArrayBuffer::getHardwareBufferBoxed),
+         makeNativeMethod("getIsHardwareBuffer", JArrayBuffer::getIsHardwareBuffer),
+         makeNativeMethod("getIsOwner", JArrayBuffer::getIsOwner), makeNativeMethod("getBufferSize", JArrayBuffer::getBufferSize)});
+  }
+};
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JHardwareBufferUtils.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JHardwareBufferUtils.hpp
new file mode 100644
index 0000000..36c28d8
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JHardwareBufferUtils.hpp
@@ -0,0 +1,39 @@
+//
+//  JHardwareBufferUtils.hpp
+//  react-native-nitro
+//
+//  Created by Marc Rousavy on 11.07.25.
+//
+
+#pragma once
+
+#include <android/hardware_buffer.h>
+#include <fbjni/fbjni.h>
+
+namespace margelo::nitro {
+
+using namespace facebook;
+
+class JHardwareBufferUtils final : public jni::JavaClass<JHardwareBufferUtils> {
+public:
+  static auto constexpr kJavaDescriptor = "Lcom/margelo/nitro/utils/HardwareBufferUtils;";
+
+public:
+  static size_t getHardwareBufferSize(AHardwareBuffer* hardwareBuffer);
+
+  static void copyHardwareBufferBoxed(jni::alias_ref<jni::JClass>, jni::alias_ref<jni::JObject> boxedSourceHardwareBuffer,
+                                      jni::alias_ref<jni::JObject> boxedDestinationHardwareBuffer);
+
+  static jni::local_ref<jni::JObject> copyHardwareBufferBoxedNew(jni::alias_ref<jni::JClass>,
+                                                                 jni::alias_ref<jni::JObject> boxedSourceHardwareBuffer);
+
+  static void copyHardwareBuffer(AHardwareBuffer* sourceHardwareBuffer, AHardwareBuffer* destinationHardwareBuffer);
+
+public:
+  static void registerNatives() {
+    javaClassStatic()->registerNatives({makeNativeMethod("copyHardwareBuffer", JHardwareBufferUtils::copyHardwareBufferBoxed),
+                                        makeNativeMethod("copyHardwareBuffer", JHardwareBufferUtils::copyHardwareBufferBoxedNew)});
+  }
+};
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JHybridObject.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JHybridObject.hpp
new file mode 100644
index 0000000..c03c734
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JHybridObject.hpp
@@ -0,0 +1,44 @@
+//
+//  JHybridObject.hpp
+//  react-native-nitro
+//
+//  Created by Marc Rousavy on 14.07.24.
+//
+
+#pragma once
+
+#include "HybridObject.hpp"
+#include <fbjni/fbjni.h>
+
+namespace margelo::nitro {
+
+using namespace facebook;
+
+/**
+ * Represents the Java `HybridObject` instance.
+ * HybridData is passed up from inherited members, so this acts like a base class
+ * and has to be inherited as "virtual" in C++ to properly avoid creating multiple `HybridObject` instances.
+ */
+class JHybridObject : public jni::HybridClass<JHybridObject>, public virtual HybridObject {
+public:
+  static auto constexpr kJavaDescriptor = "Lcom/margelo/nitro/core/HybridObject;";
+
+public:
+  // C++ constructor (called from Java via `initHybrid()`)
+  explicit JHybridObject(jni::alias_ref<jhybridobject> jThis) : _javaPart(jni::make_global(jThis)) {}
+  // C++ default constructor used by older Nitro versions (deprecated in favor of the jThis one)
+  [[deprecated]] JHybridObject() = default;
+
+public:
+  ~JHybridObject() override;
+
+public:
+  // `shared()` has custom logic because we ref-count using `jni::global_ref`!
+  std::shared_ptr<HybridObject> shared() override;
+
+private:
+  jni::global_ref<JHybridObject::javaobject> _javaPart;
+  friend HybridBase;
+};
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JHybridObjectInitializer.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JHybridObjectInitializer.hpp
new file mode 100644
index 0000000..d26f100
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JHybridObjectInitializer.hpp
@@ -0,0 +1,29 @@
+//
+//  JHybridObjectInitializer.hpp
+//  react-native-nitro
+//
+//  Created by Marc Rousavy on 22.07.24.
+//
+
+#pragma once
+
+#include "HybridObject.hpp"
+#include "JHybridObject.hpp"
+#include <fbjni/fbjni.h>
+
+namespace margelo::nitro {
+
+using namespace facebook;
+
+struct JHybridObjectInitializer : public jni::JavaClass<JHybridObjectInitializer> {
+public:
+  jni::local_ref<JHybridObject::javaobject> call() const {
+    const auto method = this->javaClassStatic()->getMethod<JHybridObject::javaobject()>("initialize");
+    return method(self());
+  }
+
+public:
+  static auto constexpr kJavaDescriptor = "Lcom/margelo/nitro/core/HybridObjectInitializer;";
+};
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JInstant.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JInstant.hpp
new file mode 100644
index 0000000..b2b1d17
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JInstant.hpp
@@ -0,0 +1,54 @@
+//
+//  JInstant.hpp
+//  react-native-nitro
+//
+//  Created by Marc Rousavy on 19.11.24.
+//
+
+#pragma once
+
+#include <chrono>
+#include <fbjni/fbjni.h>
+#include <jni.h>
+
+namespace margelo::nitro {
+
+using namespace facebook;
+using namespace std;
+
+/**
+ * Represents an `Instant` from Kotlin.
+ */
+struct JInstant final : public jni::JavaClass<JInstant> {
+public:
+  static constexpr auto kJavaDescriptor = "Ljava/time/Instant;";
+
+public:
+  static jni::local_ref<JInstant> ofEpochMilliseconds(jlong millisecondsSinceEpoch) {
+    static const auto clazz = javaClassStatic();
+    static const auto method = clazz->getStaticMethod<jni::local_ref<JInstant>(jlong)>("ofEpochMilli");
+    return method(clazz, millisecondsSinceEpoch);
+  }
+
+  static jni::local_ref<JInstant> fromChrono(chrono::system_clock::time_point date) {
+    auto timeSinceEpoch = date.time_since_epoch();
+    long long milliseconds = chrono::duration_cast<chrono::milliseconds>(timeSinceEpoch).count();
+    return JInstant::ofEpochMilliseconds(static_cast<jlong>(milliseconds));
+  }
+
+public:
+  jlong toEpochMilliseconds() {
+    static const auto clazz = javaClassStatic();
+    const auto method = clazz->getMethod<jlong()>("toEpochMilli");
+    return method(self());
+  }
+
+  chrono::system_clock::time_point toChrono() {
+    jlong millisecondsSinceEpoch = toEpochMilliseconds();
+    auto duration = chrono::duration<long, std::milli>(static_cast<long>(millisecondsSinceEpoch));
+    auto date = chrono::system_clock::time_point(chrono::duration_cast<chrono::system_clock::duration>(duration));
+    return date;
+  }
+};
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JNICallable.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JNICallable.hpp
new file mode 100644
index 0000000..10adf02
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JNICallable.hpp
@@ -0,0 +1,50 @@
+//
+//  JNICallable.hpp
+//  react-native-nitro
+//
+//  Created by Marc Rousavy on 20.11.25.
+//
+
+#pragma once
+
+#include "NitroDefines.hpp"
+#include <fbjni/fbjni.h>
+
+namespace margelo::nitro {
+
+using namespace facebook;
+
+// Signature = R(Args...)
+template <typename JFunc, typename Signature>
+class JNICallable;
+
+/**
+ * A wrapper for any jni::JavaClass that implements `R invoke(Args...)` to
+ * make it callable (e.g. conformable to `std::function<R(Args...)>`)
+ * The `jni::global_ref` is safely deleted.
+ */
+template <typename JFunc, typename R, typename... Args>
+class JNICallable<JFunc, R(Args...)> final {
+public:
+  using Signature = R(Args...);
+
+  explicit JNICallable(jni::global_ref<JFunc>&& func) : _func(std::move(func)) {}
+  ~JNICallable() {
+    // Hermes GC can destroy JS objects on a non-JNI Thread.
+    jni::ThreadScope::WithClassLoader([&] { _func.reset(); });
+  }
+
+public:
+  inline R operator()(Args... args) const {
+    if constexpr (std::is_void_v<R>) {
+      _func->invoke(std::forward<Args>(args)...);
+    } else {
+      return _func->invoke(std::forward<Args>(args)...);
+    }
+  }
+
+private:
+  jni::global_ref<JFunc> _func;
+};
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JNISharedPtr.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JNISharedPtr.hpp
new file mode 100644
index 0000000..aa71a24
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JNISharedPtr.hpp
@@ -0,0 +1,69 @@
+//
+// Created by Marc Rousavy on 21.02.24.
+//
+
+#pragma once
+
+#include "NitroDefines.hpp"
+#include "NitroTypeInfo.hpp"
+#include <fbjni/fbjni.h>
+#include <memory>
+
+namespace margelo::nitro {
+
+using namespace facebook;
+
+template <typename T>
+struct GlobalRefDeleter {
+  explicit GlobalRefDeleter(const jni::global_ref<typename T::javaobject>& ref) : _ref(ref) {}
+
+  GlobalRefDeleter(const GlobalRefDeleter& copy) = delete;
+  GlobalRefDeleter(GlobalRefDeleter&& move) = default;
+
+  void operator()(T* /* cthis */) {
+    // It's RAII - once `GlobalRefDeleter` goes out of scope, `jni::global_ref` will too.
+    jni::ThreadScope::WithClassLoader([&] { _ref.reset(); });
+  }
+
+private:
+  jni::global_ref<typename T::javaobject> _ref;
+};
+
+class JNISharedPtr final {
+private:
+  template <typename T, template <typename, typename...> class Base>
+  struct is_base_template_of {
+    template <typename U>
+    static std::true_type test(Base<U>*) {}
+
+    template <typename>
+    static std::false_type test(...) {}
+
+    static constexpr bool value = decltype(test<T>(nullptr))::value;
+  };
+
+public:
+  JNISharedPtr() = delete;
+  ~JNISharedPtr() = delete;
+
+public:
+  /**
+   * Creates a new `std::shared_ptr<T>` from the given `jni::global_ref<T::javaobject>`.
+   * Note: This does not perform any caching and will just re-create the shared_ptr control-block
+   *       each time. It is not safe to call this multiple times if you use enable_shared_from_this.
+   *       Instead, use HybridObject::shared().
+   */
+  template <typename T, typename std::enable_if<is_base_template_of<T, jni::HybridClass>::value, int>::type = 0>
+  static std::shared_ptr<T> make_shared_from_jni(const jni::global_ref<typename T::javaobject>& ref) {
+#ifdef NITRO_DEBUG
+    if (ref == nullptr || ref->cthis() == nullptr) [[unlikely]] {
+      std::string typeName = TypeInfo::getFriendlyTypename<T>(true);
+      throw std::runtime_error("Failed to wrap jni::global_ref<" + typeName + "::javaobject> in std::shared_ptr<" + typeName +
+                               "> - it's null!");
+    }
+#endif
+    return std::shared_ptr<T>(ref->cthis(), GlobalRefDeleter<T>(ref));
+  }
+};
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JNitroModules.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JNitroModules.hpp
new file mode 100644
index 0000000..e31b66c
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JNitroModules.hpp
@@ -0,0 +1,37 @@
+//
+// Created by Marc Rousavy on 07.10.24.
+//
+
+#pragma once
+
+#include <ReactCommon/CallInvoker.h>
+#include <ReactCommon/CallInvokerHolder.h>
+#include <fbjni/fbjni.h>
+#include <jsi/jsi.h>
+
+namespace margelo::nitro {
+
+using namespace facebook;
+
+class JNitroModules final : public jni::HybridClass<JNitroModules> {
+public:
+  static auto constexpr kJavaDescriptor = "Lcom/margelo/nitro/NitroModules;";
+
+private:
+  explicit JNitroModules() = default;
+
+private:
+  // JNI Methods
+  static jni::local_ref<JNitroModules::jhybriddata> initHybrid(jni::alias_ref<jhybridobject> javaThis);
+  void install(jlong runtimePointer, jni::alias_ref<react::CallInvokerHolder::javaobject> callInvokerHolder);
+
+private:
+  static auto constexpr TAG = "NitroModules";
+  using HybridBase::HybridBase;
+  friend HybridBase;
+
+public:
+  static void registerNatives();
+};
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JNull.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JNull.hpp
new file mode 100644
index 0000000..a2352a9
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JNull.hpp
@@ -0,0 +1,33 @@
+//
+//  JNull.hpp
+//  react-native-nitro
+//
+//  Created by Marc Rousavy on 10.11.25
+//
+
+#pragma once
+
+#include <fbjni/fbjni.h>
+
+namespace margelo::nitro {
+
+using namespace facebook;
+
+/**
+ * Represents a `Null` from Kotlin.
+ */
+struct JNull final : public jni::JavaClass<JNull> {
+public:
+  static constexpr auto kJavaDescriptor = "Lcom/margelo/nitro/core/NullType;";
+
+public:
+  static jni::global_ref<JNull> null() {
+    static const auto clazz = javaClassStatic();
+    static const auto nullField = clazz->getStaticField<JNull>("NULL");
+    static const auto nullValue = clazz->getStaticFieldValue(nullField);
+    static const auto globalNullValue = jni::make_global(nullValue);
+    return globalNullValue;
+  }
+};
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JPromise.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JPromise.hpp
new file mode 100644
index 0000000..4ece344
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JPromise.hpp
@@ -0,0 +1,167 @@
+//
+//  JPromise.hpp
+//  react-native-nitro
+//
+//  Created by Marc Rousavy on 14.07.24.
+//
+
+#pragma once
+
+#include "Promise.hpp"
+#include <fbjni/fbjni.h>
+#include <mutex>
+#include <variant>
+
+namespace margelo::nitro {
+
+using namespace facebook;
+
+struct JOnResolvedCallback : public jni::JavaClass<JOnResolvedCallback> {
+  static auto constexpr kJavaDescriptor = "Lcom/margelo/nitro/core/Promise$OnResolvedCallback;";
+  void onResolved(const jni::alias_ref<jni::JObject>& result) const {
+    static const auto method = javaClassLocal()->getMethod<void(jni::alias_ref<jni::JObject>)>("onResolved");
+    method(self(), result);
+  }
+};
+
+struct JOnRejectedCallback : public jni::JavaClass<JOnRejectedCallback> {
+  static auto constexpr kJavaDescriptor = "Lcom/margelo/nitro/core/Promise$OnRejectedCallback;";
+  void onRejected(const jni::alias_ref<jni::JThrowable>& error) const {
+    static const auto method = javaClassLocal()->getMethod<void(jni::alias_ref<jni::JThrowable>)>("onRejected");
+    method(self(), error);
+  }
+};
+
+/**
+ * Represents a Promise implemented in Java.
+ */
+class JPromise final : public jni::HybridClass<JPromise> {
+public:
+  static auto constexpr kJavaDescriptor = "Lcom/margelo/nitro/core/Promise;";
+  using ResultType = jni::global_ref<jni::JObject>;
+  using ErrorType = jni::global_ref<jni::JThrowable>;
+  using OnResolvedFunc = std::function<void(jni::alias_ref<jni::JObject>)>;
+  using OnRejectedFunc = std::function<void(jni::alias_ref<jni::JThrowable>)>;
+
+private:
+  /**
+   * Create a new, still unresolved `JPromise` from Java.
+   */
+  static jni::local_ref<JPromise::jhybriddata> initHybrid(jni::alias_ref<jhybridobject>) {
+    return makeCxxInstance();
+  }
+
+public:
+  /**
+   * Create a new, still unresolved `JPromise` from C++.
+   */
+  static jni::local_ref<JPromise::javaobject> create() {
+    return newObjectCxxArgs();
+  }
+
+public:
+  ~JPromise() override {
+    if (isPending()) [[unlikely]] {
+      jni::ThreadScope::WithClassLoader([&]() {
+        std::runtime_error error("Timeouted: JPromise was destroyed!");
+        this->reject(jni::getJavaExceptionForCppException(std::make_exception_ptr(error)));
+      });
+    }
+  }
+
+public:
+  void resolve(jni::alias_ref<jni::JObject> result) {
+    std::unique_lock lock(_mutex);
+    jni::global_ref<jni::JObject> globalResult = jni::make_global(result);
+    _state = globalResult;
+    for (const auto& onResolved : _onResolvedListeners) {
+      onResolved(result);
+    }
+  }
+  void reject(jni::alias_ref<jni::JThrowable> error) {
+    std::unique_lock lock(_mutex);
+    jni::global_ref<jni::JThrowable> globalError = jni::make_global(error);
+    _state = globalError;
+    for (const auto& onRejected : _onRejectedListeners) {
+      onRejected(error);
+    }
+  }
+
+public:
+  void addOnResolvedListener(OnResolvedFunc&& onResolved) {
+    std::unique_lock lock(_mutex);
+    if (auto result = std::get_if<ResultType>(&_state)) {
+      // Promise is already resolved! Call the callback immediately
+      onResolved(*result);
+    } else {
+      // Promise is not yet resolved, put the listener in our queue.
+      _onResolvedListeners.push_back(std::move(onResolved));
+    }
+  }
+  void addOnRejectedListener(OnRejectedFunc&& onRejected) {
+    std::unique_lock lock(_mutex);
+    if (auto error = std::get_if<ErrorType>(&_state)) {
+      // Promise is already rejected! Call the callback immediately
+      onRejected(*error);
+    } else {
+      // Promise is not yet rejected, put the listener in our queue.
+      _onRejectedListeners.push_back(std::move(onRejected));
+    }
+  }
+
+private:
+  void addOnResolvedListenerJava(jni::alias_ref<JOnResolvedCallback> callback) {
+    std::unique_lock lock(_mutex);
+    if (auto result = std::get_if<ResultType>(&_state)) {
+      // Promise is already resolved! Call the callback immediately
+      callback->onResolved(*result);
+    } else {
+      // Promise is not yet resolved, put the listener in our queue.
+      auto sharedCallback = jni::make_global(callback);
+      _onResolvedListeners.emplace_back(
+          [sharedCallback = std::move(sharedCallback)](const auto& result) { sharedCallback->onResolved(result); });
+    }
+  }
+  void addOnRejectedListenerJava(jni::alias_ref<JOnRejectedCallback> callback) {
+    std::unique_lock lock(_mutex);
+    if (auto error = std::get_if<ErrorType>(&_state)) {
+      // Promise is already rejected! Call the callback immediately
+      callback->onRejected(*error);
+    } else {
+      // Promise is not yet rejected, put the listener in our queue.
+      auto sharedCallback = jni::make_global(callback);
+      _onRejectedListeners.emplace_back(
+          [sharedCallback = std::move(sharedCallback)](const auto& error) { sharedCallback->onRejected(error); });
+    }
+  }
+
+private:
+  [[nodiscard]]
+  bool isPending() const noexcept {
+    return std::holds_alternative<std::monostate>(_state);
+  }
+
+private:
+  JPromise() = default;
+
+private:
+  friend HybridBase;
+  using HybridBase::HybridBase;
+  std::variant<std::monostate, ResultType, ErrorType> _state;
+  std::vector<OnResolvedFunc> _onResolvedListeners;
+  std::vector<OnRejectedFunc> _onRejectedListeners;
+  std::mutex _mutex;
+
+public:
+  static void registerNatives() {
+    registerHybrid({
+        makeNativeMethod("initHybrid", JPromise::initHybrid),
+        makeNativeMethod("nativeResolve", JPromise::resolve),
+        makeNativeMethod("nativeReject", JPromise::reject),
+        makeNativeMethod("addOnResolvedListener", JPromise::addOnResolvedListenerJava),
+        makeNativeMethod("addOnRejectedListener", JPromise::addOnRejectedListenerJava),
+    });
+  }
+};
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JSCallback.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JSCallback.hpp
new file mode 100644
index 0000000..638709a
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JSCallback.hpp
@@ -0,0 +1,132 @@
+//
+//  JSCallback.hpp
+//  Nitro
+//
+//  Created by Marc Rousavy on 23.02.25.
+//
+
+#pragma once
+
+namespace margelo::nitro {
+template <typename T, typename Enable>
+struct JSIConverter;
+} // namespace margelo::nitro
+
+#include "BorrowingReference.hpp"
+#include "JSIConverter.hpp"
+#include "NitroDefines.hpp"
+#include "NitroTypeInfo.hpp"
+#include "Promise.hpp"
+#include <functional>
+#include <jsi/jsi.h>
+
+namespace margelo::nitro {
+
+// -------- SyncJSCallback --------
+
+template <typename Signature>
+class SyncJSCallback;
+
+template <typename R, typename... Args>
+class SyncJSCallback<R(Args...)> final {
+public:
+  SyncJSCallback(jsi::Runtime& runtime, BorrowingReference<jsi::Function>&& function) : _runtime(runtime), _function(std::move(function)) {}
+
+public:
+  /**
+   * Calls this `SyncJSCallback` synchronously, and
+   * returns it's result (`R`).
+   * The callee is responsible for ensuring that the
+   * underlying `jsi::Function` can actually be called from this Thread.
+   * In Debug, sanity checks are made to ensure the `jsi::Function` is still alive.
+   */
+  R call(Args... args) const {
+    if (!_function) [[unlikely]] {
+      std::string typeName = TypeInfo::getFriendlyTypename<SyncJSCallback<R(Args...)>>(true);
+      throw std::runtime_error("Cannot call " + typeName + " - the underlying `jsi::Function` has already been deleted!");
+    }
+
+    jsi::Value result = _function->call(_runtime, JSIConverter<std::decay_t<Args>>::toJSI(_runtime, std::forward<Args>(args))...);
+    if constexpr (std::is_void_v<R>) {
+      // It's returning void. No result
+      return;
+    } else {
+      // It's returning a type `R`, convert it
+      return JSIConverter<R>::fromJSI(_runtime, result);
+    }
+  }
+
+public:
+  inline R operator()(Args... args) const {
+    return call(args...);
+  }
+
+private:
+  jsi::Runtime& _runtime;
+  BorrowingReference<jsi::Function> _function;
+};
+
+// -------- AsyncJSCallback --------
+
+template <typename Signature>
+class AsyncJSCallback;
+
+template <typename R, typename... Args>
+class AsyncJSCallback<R(Args...)> final {
+public:
+  AsyncJSCallback(SyncJSCallback<R(Args...)>&& callback, const std::weak_ptr<Dispatcher>& dispatcher)
+      : _callback(std::move(callback)), _dispatcher(dispatcher) {}
+
+public:
+  /**
+   * Calls this `AsyncJSCallback` asynchronously, and returns a Promise that
+   * can be awaited to receive the returned result (`R`) from JS.
+   * This can be called from any Thread.
+   * If the Runtime is no longer alive, this method throws.
+   */
+  [[nodiscard]]
+  std::shared_ptr<Promise<R>> call(Args... args) const {
+    std::shared_ptr<Dispatcher> dispatcher = _dispatcher.lock();
+    if (dispatcher == nullptr) [[unlikely]] {
+      std::string typeName = TypeInfo::getFriendlyTypename<AsyncJSCallback<R(Args...)>>(true);
+      throw std::runtime_error("Failed to call " + typeName + " - the Dispatcher has already been destroyed!");
+    }
+    return dispatcher->runAsyncAwaitable<R>([callback = _callback, ... args = std::forward<Args>(args)]() mutable {
+      // Call actual JS callback, synchronously now.
+      return callback.call(std::forward<Args>(args)...);
+    });
+  }
+  /**
+   * Calls this `AsyncJSCallback` asynchronously, and ignore
+   * any results or completions.
+   * This can be called from any Thread.
+   * If the Runtime is no longer alive, this method ignores the function call.
+   */
+  void callAndForget(Args... args) const {
+    std::shared_ptr<Dispatcher> dispatcher = _dispatcher.lock();
+    if (dispatcher == nullptr) [[unlikely]] {
+      std::string typeName = TypeInfo::getFriendlyTypename<AsyncJSCallback<R(Args...)>>(true);
+      Logger::log(LogLevel::Error, "AsyncJSCallback", "Failed to call %s - the Dispatcher has already been destroyed!", typeName.c_str());
+      return;
+    }
+    dispatcher->runAsync([callback = _callback, ... args = std::forward<Args>(args)]() mutable {
+      // Call actual JS callback, synchronously now.
+      return callback.call(std::forward<Args>(args)...);
+    });
+  }
+
+public:
+  inline auto operator()(Args... args) const {
+    if constexpr (std::is_void_v<R>) {
+      return callAndForget(args...);
+    } else {
+      return call(args...);
+    }
+  }
+
+private:
+  SyncJSCallback<R(Args...)> _callback;
+  std::weak_ptr<Dispatcher> _dispatcher;
+};
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JSICache.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JSICache.hpp
new file mode 100644
index 0000000..f63f610
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JSICache.hpp
@@ -0,0 +1,123 @@
+//
+//  JSICache.hpp
+//  NitroModules
+//
+//  Created by Marc Rousavy on 20.06.24.
+//
+
+#pragma once
+
+#include "BorrowingReference.hpp"
+#include "NitroLogger.hpp"
+#include "WeakReference.hpp"
+#include <jsi/jsi.h>
+#include <memory>
+#include <mutex>
+#include <unordered_map>
+#include <vector>
+
+namespace margelo::nitro {
+
+using namespace facebook;
+
+class JSICacheReference;
+
+/**
+ * A `JSICache` can safely store `jsi::Value` instances (e.g. `jsi::Object` or
+ * `jsi::Function`) inside `BorrowingReference<T>`.
+ *
+ * `jsi::Value`s are managed by a `jsi::Runtime`, and will be deleted if the `jsi::Runtime`
+ * is deleted - even if there are still strong references to the `jsi::Value`.
+ *
+ * To access a `BorrowingReference<jsi::Value>` safely, make sure you are using it from
+ * the same Thread that it was created on. This ensures that the `jsi::Runtime` cannot
+ * delete it while you are still using it.
+ */
+class JSICache final : public jsi::NativeState {
+public:
+  ~JSICache();
+
+public:
+  JSICache(const JSICache&) = delete;
+  JSICache(JSICache&&) = delete;
+
+private:
+  JSICache() = default;
+
+public:
+  /**
+   Gets or creates a `JSICache` for the given `jsi::Runtime`.
+   The returned `shared_ptr` should not be stored in
+   If it can be locked, you can access data in the cache. Otherwise the Runtime has already been deleted.
+   Do not hold the returned `shared_ptr` in memory, only use it in the calling function's scope.
+   */
+  [[nodiscard]]
+  static JSICacheReference getOrCreateCache(jsi::Runtime& runtime);
+
+private:
+  friend class JSICacheReference;
+
+private:
+  std::mutex _mutex;
+  std::vector<WeakReference<jsi::Value>> _valueCache;
+  std::vector<WeakReference<jsi::Object>> _objectCache;
+  std::vector<WeakReference<jsi::Function>> _functionCache;
+  std::vector<WeakReference<jsi::WeakObject>> _weakObjectCache;
+  std::vector<WeakReference<jsi::ArrayBuffer>> _arrayBufferCache;
+
+private:
+  static inline std::unordered_map<jsi::Runtime*, std::weak_ptr<JSICache>> _globalCache;
+
+private:
+  static constexpr auto TAG = "JSICache";
+};
+
+class JSICacheReference final {
+public:
+  JSICacheReference() = delete;
+  JSICacheReference(const JSICacheReference&) = delete;
+  JSICacheReference(JSICacheReference&&) = delete;
+
+  ~JSICacheReference() {
+    _strongCache->_mutex.unlock();
+  }
+
+public:
+  BorrowingReference<jsi::Value> makeShared(jsi::Value&& value) {
+    BorrowingReference<jsi::Value> owning(new jsi::Value(std::move(value)));
+    _strongCache->_valueCache.push_back(owning.weak());
+    return owning;
+  }
+  BorrowingReference<jsi::Object> makeShared(jsi::Object&& value) {
+    BorrowingReference<jsi::Object> owning(new jsi::Object(std::move(value)));
+    _strongCache->_objectCache.push_back(owning.weak());
+    return owning;
+  }
+  BorrowingReference<jsi::Function> makeShared(jsi::Function&& value) {
+    BorrowingReference<jsi::Function> owning(new jsi::Function(std::move(value)));
+    _strongCache->_functionCache.push_back(owning.weak());
+    return owning;
+  }
+  BorrowingReference<jsi::WeakObject> makeShared(jsi::WeakObject&& value) {
+    BorrowingReference<jsi::WeakObject> owning(new jsi::WeakObject(std::move(value)));
+    _strongCache->_weakObjectCache.push_back(owning.weak());
+    return owning;
+  }
+  BorrowingReference<jsi::ArrayBuffer> makeShared(jsi::ArrayBuffer&& value) {
+    BorrowingReference<jsi::ArrayBuffer> owning(new jsi::ArrayBuffer(std::move(value)));
+    _strongCache->_arrayBufferCache.push_back(owning.weak());
+    return owning;
+  }
+
+private:
+  explicit JSICacheReference(const std::shared_ptr<JSICache>& cache) : _strongCache(cache) {
+    _strongCache->_mutex.lock();
+  }
+
+private:
+  std::shared_ptr<JSICache> _strongCache;
+
+  friend class JSICache;
+};
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JSIConverter+AnyMap.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JSIConverter+AnyMap.hpp
new file mode 100644
index 0000000..8c6471a
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JSIConverter+AnyMap.hpp
@@ -0,0 +1,86 @@
+//
+// Created by Marc Rousavy on 21.02.24.
+//
+
+#pragma once
+
+// Forward declare a few of the common types that might have cyclic includes.
+namespace margelo::nitro {
+struct AnyValue;
+class AnyMap;
+
+template <typename T, typename Enable>
+struct JSIConverter;
+} // namespace margelo::nitro
+
+#include "JSIConverter+Variant.hpp"
+#include "JSIConverter.hpp"
+
+#include "AnyMap.hpp"
+#include "JSIHelpers.hpp"
+#include <jsi/jsi.h>
+#include <memory>
+
+namespace margelo::nitro {
+
+using namespace facebook;
+
+// AnyValue <> Record<K, V>
+template <>
+struct JSIConverter<AnyValue> final {
+  static inline AnyValue fromJSI(jsi::Runtime& runtime, const jsi::Value& arg) {
+    return JSIConverter<AnyValue::variant>::fromJSI(runtime, arg);
+  }
+  static inline jsi::Value toJSI(jsi::Runtime& runtime, const AnyValue& value) {
+    return JSIConverter<AnyValue::variant>::toJSI(runtime, value);
+  }
+  static inline bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) {
+    return JSIConverter<AnyValue::variant>::canConvert(runtime, value);
+  }
+};
+
+// AnyMap <> Record<K, V>
+template <>
+struct JSIConverter<std::shared_ptr<AnyMap>> final {
+  static inline std::shared_ptr<AnyMap> fromJSI(jsi::Runtime& runtime, const jsi::Value& arg) {
+    jsi::Object object = arg.asObject(runtime);
+    jsi::Array propNames = object.getPropertyNames(runtime);
+    size_t size = propNames.size(runtime);
+    std::shared_ptr<AnyMap> map = AnyMap::make();
+    for (size_t i = 0; i < size; i++) {
+      jsi::String jsKey = propNames.getValueAtIndex(runtime, i).getString(runtime);
+      jsi::Value jsValue = object.getProperty(runtime, jsKey);
+      map->setAny(jsKey.utf8(runtime), JSIConverter<AnyValue>::fromJSI(runtime, jsValue));
+    }
+    return map;
+  }
+  static inline jsi::Value toJSI(jsi::Runtime& runtime, std::shared_ptr<AnyMap> map) {
+    jsi::Object object(runtime);
+    for (const auto& item : map->getMap()) {
+      jsi::String key = jsi::String::createFromUtf8(runtime, item.first);
+      jsi::Value value = JSIConverter<AnyValue>::toJSI(runtime, item.second);
+      object.setProperty(runtime, std::move(key), std::move(value));
+    }
+    return object;
+  }
+  static inline bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) {
+    if (!value.isObject()) {
+      return false;
+    }
+    jsi::Object object = value.getObject(runtime);
+    if (!isPlainObject(runtime, object)) {
+      return false;
+    }
+    jsi::Array properties = object.getPropertyNames(runtime);
+    size_t size = properties.size(runtime);
+    for (size_t i = 0; i < size; i++) {
+      bool canConvertProp = JSIConverter<AnyValue>::canConvert(runtime, properties.getValueAtIndex(runtime, i));
+      if (!canConvertProp) {
+        return false;
+      }
+    }
+    return true;
+  }
+};
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JSIConverter+ArrayBuffer.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JSIConverter+ArrayBuffer.hpp
new file mode 100644
index 0000000..ff18144
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JSIConverter+ArrayBuffer.hpp
@@ -0,0 +1,96 @@
+//
+// Created by Marc Rousavy on 21.02.24.
+//
+
+#pragma once
+
+// Forward declare a few of the common types that might have cyclic includes.
+namespace margelo::nitro {
+class ArrayBuffer;
+class JSICache;
+
+template <typename T, typename Enable>
+struct JSIConverter;
+} // namespace margelo::nitro
+
+#include "JSIConverter.hpp"
+
+#include "ArrayBuffer.hpp"
+#include "IsSharedPtrTo.hpp"
+#include "JSICache.hpp"
+#include "NitroDefines.hpp"
+#include <jsi/jsi.h>
+#include <memory>
+#include <type_traits>
+
+namespace margelo::nitro {
+
+using namespace facebook;
+
+struct MutableBufferNativeState final : public jsi::NativeState {
+public:
+  explicit MutableBufferNativeState(const std::shared_ptr<jsi::MutableBuffer>& buffer) : buffer(buffer) {}
+  std::shared_ptr<jsi::MutableBuffer> buffer;
+};
+
+// MutableBuffer <> ArrayBuffer
+template <typename T>
+struct JSIConverter<T, std::enable_if_t<is_shared_ptr_to_v<T, jsi::MutableBuffer>>> final {
+  static inline std::shared_ptr<ArrayBuffer> fromJSI(jsi::Runtime& runtime, const jsi::Value& arg) {
+#ifdef NITRO_DEBUG
+    if (!arg.isObject()) [[unlikely]] {
+      throw std::invalid_argument("Value \"" + arg.toString(runtime).utf8(runtime) +
+                                  "\" is not an ArrayBuffer - "
+                                  "in fact, it's not even an object!");
+    }
+#endif
+
+    jsi::Object object = arg.asObject(runtime);
+#ifdef NITRO_DEBUG
+    if (!object.isArrayBuffer(runtime)) [[unlikely]] {
+      throw std::invalid_argument("Object \"" + arg.toString(runtime).utf8(runtime) +
+                                  "\" is not an ArrayBuffer! "
+                                  "Are you maybe passing a TypedArray (e.g. Uint8Array)? Try to pass it's `.buffer` value.");
+    }
+#endif
+    if (object.hasNativeState<MutableBufferNativeState>(runtime)) {
+      // It already is a NativeBuffer! Let's get the jsi::MutableBuffer from the jsi::NativeState...
+      auto mutableBufferHolder = object.getNativeState<MutableBufferNativeState>(runtime);
+      auto mutableBuffer = mutableBufferHolder->buffer;
+      if (auto arrayBuffer = std::dynamic_pointer_cast<ArrayBuffer>(mutableBuffer)) [[likely]] {
+        return arrayBuffer;
+      }
+    }
+
+    JSICacheReference cache = JSICache::getOrCreateCache(runtime);
+    auto borrowingArrayBuffer = cache.makeShared(object.getArrayBuffer(runtime));
+
+    return std::make_shared<JSArrayBuffer>(runtime, borrowingArrayBuffer);
+  }
+  static inline jsi::Value toJSI(jsi::Runtime& runtime, const std::shared_ptr<jsi::MutableBuffer>& buffer) {
+    if (auto jsBuffer = std::dynamic_pointer_cast<JSArrayBuffer>(buffer)) {
+      // It already is a JSBuffer! Let's try to just get it's existing jsi::Value...
+      auto jsValue = jsBuffer->getJSReference();
+      if (jsValue != nullptr) [[likely]] {
+        return jsi::Value(runtime, *jsValue);
+      }
+    }
+
+    // 1. Create jsi::ArrayBuffer
+    jsi::ArrayBuffer arrayBuffer(runtime, buffer);
+    // 2. Wrap jsi::MutableBuffer in jsi::NativeState holder & attach it
+    auto mutableBufferHolder = std::make_shared<MutableBufferNativeState>(buffer);
+    arrayBuffer.setNativeState(runtime, mutableBufferHolder);
+    // 3. Return jsi::ArrayBuffer (with jsi::NativeState) to JS
+    return arrayBuffer;
+  }
+  static inline bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) {
+    if (value.isObject()) {
+      jsi::Object object = value.getObject(runtime);
+      return object.isArrayBuffer(runtime);
+    }
+    return false;
+  }
+};
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JSIConverter+Date.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JSIConverter+Date.hpp
new file mode 100644
index 0000000..42f5e42
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JSIConverter+Date.hpp
@@ -0,0 +1,83 @@
+//
+// Created by Marc Rousavy on 04.06.25.
+//
+
+#pragma once
+
+// Forward declare a few of the common types that might have cyclic includes.
+namespace margelo::nitro {
+class JSICache;
+
+template <typename T, typename Enable>
+struct JSIConverter;
+} // namespace margelo::nitro
+
+#include "JSIConverter.hpp"
+
+#include <chrono>
+#include <jsi/jsi.h>
+#include <memory>
+#include <type_traits>
+
+namespace margelo::nitro {
+
+using namespace facebook;
+using namespace std;
+
+// Date <> chrono::system_clock::time_point
+template <>
+struct JSIConverter<std::chrono::system_clock::time_point> final {
+  static inline chrono::system_clock::time_point fromJSI(jsi::Runtime& runtime, const jsi::Value& arg) {
+#ifdef NITRO_DEBUG
+    if (!arg.isObject()) [[unlikely]] {
+      throw std::invalid_argument("Value \"" + arg.toString(runtime).utf8(runtime) +
+                                  "\" is not a Date - in fact, "
+                                  "it's not even an object!");
+    }
+#endif
+
+    jsi::Object object = arg.asObject(runtime);
+#ifdef NITRO_DEBUG
+    if (!object.hasProperty(runtime, "getTime")) {
+      throw std::invalid_argument("Object \"" + arg.toString(runtime).utf8(runtime) +
+                                  "\" does not have a .getTime() function! "
+                                  "It's not a valid Date object.");
+    }
+#endif
+
+    // TODO: Cache this
+    jsi::Function getTimeFunc = object.getPropertyAsFunction(runtime, "getTime");
+    double msSinceEpoch = getTimeFunc.callWithThis(runtime, object).getNumber();
+
+    // ms -> std::chrono::system_clock::time_point
+    auto durationMs = chrono::duration<double, std::milli>(msSinceEpoch);
+    auto duration = chrono::duration_cast<chrono::system_clock::duration>(durationMs);
+    auto timePoint = chrono::system_clock::time_point(duration);
+
+    return timePoint;
+  }
+
+  static inline jsi::Value toJSI(jsi::Runtime& runtime, const chrono::system_clock::time_point& date) {
+    // 1. Get milliseconds since epoch as a double
+    auto ms = chrono::duration_cast<chrono::milliseconds>(date.time_since_epoch()).count();
+    auto msSinceEpoch = static_cast<double>(ms);
+
+    // TODO: Cache this
+    jsi::Function dateCtor = runtime.global().getPropertyAsFunction(runtime, "Date");
+
+    jsi::Value jsDate = dateCtor.callAsConstructor(runtime, {jsi::Value(msSinceEpoch)});
+    return jsDate;
+  }
+
+  static inline bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) {
+    if (value.isObject()) {
+      jsi::Object object = value.getObject(runtime);
+
+      jsi::Function dateCtor = runtime.global().getPropertyAsFunction(runtime, "Date");
+      return object.instanceOf(runtime, dateCtor);
+    }
+    return false;
+  }
+};
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JSIConverter+Exception.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JSIConverter+Exception.hpp
new file mode 100644
index 0000000..7f9b662
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JSIConverter+Exception.hpp
@@ -0,0 +1,59 @@
+//
+// Created by Marc Rousavy on 21.02.24.
+//
+
+#pragma once
+
+// Forward declare a few of the common types that might have cyclic includes.
+namespace margelo::nitro {
+template <typename T, typename Enable>
+struct JSIConverter;
+} // namespace margelo::nitro
+
+#include "JSIConverter.hpp"
+
+#include "NitroTypeInfo.hpp"
+#include <exception>
+#include <jsi/jsi.h>
+
+namespace margelo::nitro {
+
+using namespace facebook;
+
+// std::exception_ptr <> Error
+template <>
+struct JSIConverter<std::exception_ptr> final {
+  static inline std::exception_ptr fromJSI(jsi::Runtime& runtime, const jsi::Value& error) {
+    jsi::Object object = error.asObject(runtime);
+    std::string name = object.getProperty(runtime, "name").asString(runtime).utf8(runtime);
+    std::string message = object.getProperty(runtime, "message").asString(runtime).utf8(runtime);
+    return std::make_exception_ptr(std::runtime_error(name + ": " + message));
+  }
+  static inline jsi::Value toJSI(jsi::Runtime& runtime, const std::exception_ptr& exception) {
+    if (exception == nullptr) [[unlikely]] {
+      throw std::runtime_error("Cannot convert a nullptr exception_ptr to a JS Error!");
+    }
+
+    try {
+      std::rethrow_exception(exception);
+    } catch (const std::exception& e) {
+      jsi::JSError error(runtime, e.what());
+      return jsi::Value(runtime, error.value());
+    } catch (...) {
+      // Some unknown exception was thrown - maybe an Objective-C error?
+      std::string errorName = TypeInfo::getCurrentExceptionName();
+      jsi::JSError error(runtime, "Unknown " + errorName + " error.");
+      return jsi::Value(runtime, error.value());
+    }
+  }
+  static inline bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) {
+    if (!value.isObject()) {
+      return false;
+    }
+    jsi::Object object = value.getObject(runtime);
+    jsi::Function errorCtor = runtime.global().getPropertyAsFunction(runtime, "Error");
+    return object.instanceOf(runtime, errorCtor);
+  }
+};
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JSIConverter+Function.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JSIConverter+Function.hpp
new file mode 100644
index 0000000..901c423
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JSIConverter+Function.hpp
@@ -0,0 +1,92 @@
+//
+// Created by Marc Rousavy on 21.02.24.
+//
+
+#pragma once
+
+// Forward declare a few of the common types that might have cyclic includes.
+namespace margelo::nitro {
+class JSICache;
+
+template <typename T, typename Enable>
+struct JSIConverter;
+} // namespace margelo::nitro
+
+#include "Dispatcher.hpp"
+#include "JSCallback.hpp"
+#include "JSICache.hpp"
+#include "PromiseType.hpp"
+#include <jsi/jsi.h>
+
+namespace margelo::nitro {
+
+using namespace facebook;
+
+// [](Args...) -> T {} <> (Args...) => T
+template <typename R, typename... Args>
+struct JSIConverter<std::function<R(Args...)>> final {
+  // Use AsyncJSCallback or SyncJSCallback
+  inline static constexpr bool isAsync = is_promise_v<R> || std::is_void_v<R>;
+  // Promise<T> -> T
+  using ActualR = std::conditional_t<isAsync, promise_type_v<R>, R>;
+
+  static inline std::function<R(Args...)> fromJSI(jsi::Runtime& runtime, const jsi::Value& arg) {
+    // Make function global - it'll be managed by the Runtime's memory, and we only have a weak_ref to it.
+    auto cache = JSICache::getOrCreateCache(runtime);
+    jsi::Function function = arg.asObject(runtime).asFunction(runtime);
+    BorrowingReference<jsi::Function> sharedFunction = cache.makeShared(std::move(function));
+    SyncJSCallback<ActualR(Args...)> callback(runtime, std::move(sharedFunction));
+
+    if constexpr (isAsync) {
+      // Return type is `Promise<T>` or `void` - it's an async callback!
+      std::shared_ptr<Dispatcher> dispatcher = Dispatcher::getRuntimeGlobalDispatcher(runtime);
+      return AsyncJSCallback<ActualR(Args...)>(std::move(callback), dispatcher);
+    } else {
+      // Return type is `T` - it's a sync callback!
+      return callback;
+    }
+  }
+
+  static inline jsi::Value toJSI(jsi::Runtime& runtime, std::function<R(Args...)>&& function) {
+    jsi::HostFunctionType jsFunction = [function = std::move(function)](jsi::Runtime& runtime, const jsi::Value&, const jsi::Value* args,
+                                                                        size_t count) -> jsi::Value {
+      if (count != sizeof...(Args)) [[unlikely]] {
+        throw jsi::JSError(runtime, "Function expected " + std::to_string(sizeof...(Args)) + " arguments, but received " +
+                                        std::to_string(count) + "!");
+      }
+      return callHybridFunction(function, runtime, args, std::index_sequence_for<Args...>{});
+    };
+    return jsi::Function::createFromHostFunction(runtime, jsi::PropNameID::forUtf8(runtime, "hostFunction"), sizeof...(Args),
+                                                 std::move(jsFunction));
+  }
+
+  static inline jsi::Value toJSI(jsi::Runtime& runtime, const std::function<R(Args...)>& function) {
+    std::function<R(Args...)> copy = function;
+    return toJSI(runtime, std::move(copy));
+  }
+
+  static inline bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) {
+    if (value.isObject()) {
+      jsi::Object object = value.getObject(runtime);
+      return object.isFunction(runtime);
+    }
+    return false;
+  }
+
+private:
+  template <size_t... Is>
+  static inline jsi::Value callHybridFunction(const std::function<R(Args...)>& function, jsi::Runtime& runtime, const jsi::Value* args,
+                                              std::index_sequence<Is...>) {
+    if constexpr (std::is_void_v<R>) {
+      // it is a void function (will return undefined in JS)
+      function(JSIConverter<std::decay_t<Args>>::fromJSI(runtime, args[Is])...);
+      return jsi::Value::undefined();
+    } else {
+      // it is a custom type, parse it to a JS value
+      R result = function(JSIConverter<std::decay_t<Args>>::fromJSI(runtime, args[Is])...);
+      return JSIConverter<R>::toJSI(runtime, std::forward<R>(result));
+    }
+  }
+};
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JSIConverter+HostObject.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JSIConverter+HostObject.hpp
new file mode 100644
index 0000000..462e7c3
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JSIConverter+HostObject.hpp
@@ -0,0 +1,73 @@
+//
+// Created by Marc Rousavy on 07.10.24.
+//
+
+#pragma once
+
+#include "IsSharedPtrTo.hpp"
+#include "NitroDefines.hpp"
+#include "NitroTypeInfo.hpp"
+#include <jsi/jsi.h>
+#include <type_traits>
+
+namespace margelo::nitro {
+
+using namespace facebook;
+
+// jsi::HostObject <> {}
+template <typename T>
+struct JSIConverter<T, std::enable_if_t<is_shared_ptr_to_v<T, jsi::HostObject>>> final {
+  using TPointee = typename T::element_type;
+
+  static inline T fromJSI(jsi::Runtime& runtime, const jsi::Value& arg) {
+#ifdef NITRO_DEBUG
+    if (!arg.isObject()) [[unlikely]] {
+      if (arg.isUndefined()) [[unlikely]] {
+        throw jsi::JSError(runtime, invalidTypeErrorMessage("undefined", "It is undefined!"));
+      } else {
+        std::string stringRepresentation = arg.toString(runtime).utf8(runtime);
+        throw jsi::JSError(runtime, invalidTypeErrorMessage(stringRepresentation, "It is not an object!"));
+      }
+    }
+#endif
+    jsi::Object object = arg.asObject(runtime);
+
+#ifdef NITRO_DEBUG
+    if (!object.isHostObject<TPointee>(runtime)) [[unlikely]] {
+      if (!object.isHostObject(runtime)) [[unlikely]] {
+        std::string stringRepresentation = arg.toString(runtime).utf8(runtime);
+        throw jsi::JSError(runtime, invalidTypeErrorMessage(stringRepresentation, "It is not a HostObject at all!"));
+      } else {
+        std::string stringRepresentation = arg.toString(runtime).utf8(runtime);
+        throw jsi::JSError(runtime, invalidTypeErrorMessage(stringRepresentation, "It is a different HostObject<T>!"));
+      }
+    }
+#endif
+    return object.getHostObject<TPointee>(runtime);
+  }
+
+  static inline jsi::Value toJSI(jsi::Runtime& runtime, const T& arg) {
+    if (arg == nullptr) [[unlikely]] {
+      std::string typeName = TypeInfo::getFriendlyTypename<TPointee>();
+      throw jsi::JSError(runtime, "Cannot convert `nullptr` to HostObject<" + typeName + ">!");
+    }
+
+    return jsi::Object::createFromHostObject(runtime, arg);
+  }
+
+  static inline bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) {
+    if (value.isObject()) {
+      jsi::Object object = value.getObject(runtime);
+      return object.isHostObject<TPointee>(runtime);
+    }
+    return false;
+  }
+
+private:
+  static std::string invalidTypeErrorMessage(const std::string& typeDescription, const std::string& reason) {
+    std::string typeName = TypeInfo::getFriendlyTypename<TPointee>();
+    return "Cannot convert \"" + typeDescription + "\" to HostObject<" + typeName + ">! " + reason;
+  }
+};
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JSIConverter+NativeState.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JSIConverter+NativeState.hpp
new file mode 100644
index 0000000..4b2d9c9
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JSIConverter+NativeState.hpp
@@ -0,0 +1,93 @@
+//
+// Created by Marc Rousavy on 16.10.25.
+//
+
+#pragma once
+
+namespace margelo::nitro {
+class HybridObject;
+} // namespace margelo::nitro
+
+#include "IsSharedPtrTo.hpp"
+#include "NitroDefines.hpp"
+#include "NitroTypeInfo.hpp"
+#include <jsi/jsi.h>
+#include <type_traits>
+
+namespace margelo::nitro {
+
+using namespace facebook;
+
+// NativeState <> {}
+template <typename T>
+struct JSIConverter<T, std::enable_if_t<is_shared_ptr_to_v<T, jsi::NativeState>>> final {
+  using TPointee = typename T::element_type;
+
+  static inline T fromJSI(jsi::Runtime& runtime, const jsi::Value& arg) {
+#ifdef NITRO_DEBUG
+    if (!arg.isObject()) [[unlikely]] {
+      if (arg.isUndefined()) [[unlikely]] {
+        throw jsi::JSError(runtime, invalidTypeErrorMessage("undefined", "It is undefined!"));
+      } else {
+        std::string stringRepresentation = arg.toString(runtime).utf8(runtime);
+        throw jsi::JSError(runtime, invalidTypeErrorMessage(stringRepresentation, "It is not an object!"));
+      }
+    }
+#endif
+
+    jsi::Object object = arg.asObject(runtime);
+#ifdef NITRO_DEBUG
+    if (!object.hasNativeState(runtime)) [[unlikely]] {
+      std::string stringRepresentation = arg.toString(runtime).utf8(runtime);
+      throw jsi::JSError(runtime, invalidTypeErrorMessage(stringRepresentation, "It does not have a NativeState!"));
+    }
+#endif
+
+    std::shared_ptr<jsi::NativeState> nativeState = object.getNativeState(runtime);
+    std::shared_ptr<TPointee> result = std::dynamic_pointer_cast<TPointee>(nativeState);
+    if (result == nullptr) [[unlikely]] {
+      std::string stringRepresentation = arg.toString(runtime).utf8(runtime);
+      std::string typeName = TypeInfo::getFriendlyTypename<TPointee>();
+      throw jsi::JSError(runtime, invalidTypeErrorMessage(stringRepresentation, "Downcasting failed - It has a different NativeState<T>!\n"
+                                                                                "- Did you accidentally pass a different type?\n"
+                                                                                "- Is react-native-nitro-modules linked multiple times? "
+                                                                                "Ensure you don't have any duplicate symbols for `" +
+                                                                                    typeName + "` in your app's binary."));
+    }
+
+    return result;
+  }
+
+  static inline jsi::Value toJSI(jsi::Runtime& runtime, const T& arg) {
+    if (arg == nullptr) [[unlikely]] {
+      std::string typeName = TypeInfo::getFriendlyTypename<TPointee>();
+      throw jsi::JSError(runtime, "Cannot convert `nullptr` to NativeState<" + typeName + ">!");
+    }
+
+    if constexpr (std::is_base_of_v<HybridObject, TPointee>) {
+      // It's a HybridObject - use it's internal constructor which caches jsi::Objects for proper memory management!
+      return arg->toObject(runtime);
+    } else {
+      // It's any other kind of jsi::NativeState - just create it as normal. This will not have a prototype then!
+      jsi::Object object(runtime);
+      object.setNativeState(runtime, arg);
+      return object;
+    }
+  }
+
+  static inline bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) {
+    if (value.isObject()) {
+      jsi::Object object = value.getObject(runtime);
+      return object.hasNativeState<TPointee>(runtime);
+    }
+    return false;
+  }
+
+private:
+  static std::string invalidTypeErrorMessage(const std::string& typeDescription, const std::string& reason) {
+    std::string typeName = TypeInfo::getFriendlyTypename<TPointee>();
+    return "Cannot convert \"" + typeDescription + "\" to NativeState<" + typeName + ">! " + reason;
+  }
+};
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JSIConverter+Null.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JSIConverter+Null.hpp
new file mode 100644
index 0000000..d41baa8
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JSIConverter+Null.hpp
@@ -0,0 +1,38 @@
+//
+// Created by Marc Rousavy on 10.11.25.
+//
+
+#pragma once
+
+// Forward declare JSIConverter to prevent cyclic includes
+namespace margelo::nitro {
+template <typename T, typename Enable>
+struct JSIConverter;
+} // namespace margelo::nitro
+
+#include "JSIConverter.hpp"
+#include "Null.hpp"
+#include <jsi/jsi.h>
+
+namespace margelo::nitro {
+
+using namespace facebook;
+
+// NullType <> null
+template <>
+struct JSIConverter<NullType> final {
+  static inline NullType fromJSI(jsi::Runtime&, const jsi::Value& arg) {
+    if (!arg.isNull()) [[unlikely]] {
+      throw std::runtime_error("Cannot convert non-null value to NullType!");
+    }
+    return nitro::null;
+  }
+  static inline jsi::Value toJSI(jsi::Runtime&, const NullType&) {
+    return jsi::Value::null();
+  }
+  static inline bool canConvert(jsi::Runtime&, const jsi::Value& value) {
+    return value.isNull();
+  }
+};
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JSIConverter+Optional.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JSIConverter+Optional.hpp
new file mode 100644
index 0000000..93e9ae5
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JSIConverter+Optional.hpp
@@ -0,0 +1,50 @@
+//
+// Created by Marc Rousavy on 21.02.24.
+//
+
+#pragma once
+
+// Forward declare a few of the common types that might have cyclic includes.
+namespace margelo::nitro {
+template <typename T, typename Enable>
+struct JSIConverter;
+} // namespace margelo::nitro
+
+#include "JSIConverter.hpp"
+
+#include <jsi/jsi.h>
+#include <optional>
+
+namespace margelo::nitro {
+
+using namespace facebook;
+
+// std::optional<T> <> T | undefined
+template <typename TInner>
+struct JSIConverter<std::optional<TInner>> final {
+  static inline std::optional<TInner> fromJSI(jsi::Runtime& runtime, const jsi::Value& arg) {
+    if (arg.isUndefined()) {
+      return std::nullopt;
+    } else {
+      return JSIConverter<TInner>::fromJSI(runtime, arg);
+    }
+  }
+  static inline jsi::Value toJSI(jsi::Runtime& runtime, const std::optional<TInner>& arg) {
+    if (arg == std::nullopt) {
+      return jsi::Value::undefined();
+    } else {
+      return JSIConverter<TInner>::toJSI(runtime, arg.value());
+    }
+  }
+  static inline bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) {
+    if (value.isUndefined()) {
+      return true;
+    }
+    if (JSIConverter<TInner>::canConvert(runtime, value)) {
+      return true;
+    }
+    return false;
+  }
+};
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JSIConverter+Promise.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JSIConverter+Promise.hpp
new file mode 100644
index 0000000..64a0f78
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JSIConverter+Promise.hpp
@@ -0,0 +1,112 @@
+//
+// Created by Marc Rousavy on 21.02.24.
+//
+
+#pragma once
+
+// Forward declare a few of the common types that might have cyclic includes.
+namespace margelo::nitro {
+
+template <typename T, typename Enable>
+struct JSIConverter;
+} // namespace margelo::nitro
+
+#include "JSIConverter.hpp"
+#include "NitroTypeInfo.hpp"
+#include "Null.hpp"
+#include "Promise.hpp"
+#include <exception>
+#include <jsi/jsi.h>
+#include <memory>
+
+namespace margelo::nitro {
+
+using namespace facebook;
+
+// Promise<T, std::exception> <> Promise<T>
+template <typename TResult>
+struct JSIConverter<std::shared_ptr<Promise<TResult>>> final {
+  static inline std::shared_ptr<Promise<TResult>> fromJSI(jsi::Runtime& runtime, const jsi::Value& value) {
+    // Create new Promise and prepare onResolved / onRejected callbacks
+    auto promise = Promise<TResult>::create();
+    auto thenCallback = [&]() {
+      if constexpr (std::is_void_v<TResult>) {
+        // void: resolve()
+        // std::monostate is used as a placeholder for the first argument
+        return JSIConverter<std::function<void(std::monostate)>>::toJSI(runtime, [=](std::monostate) { promise->resolve(); });
+      } else {
+        // T: resolve(T)
+        return JSIConverter<std::function<void(TResult)>>::toJSI(runtime, [=](const TResult& result) { promise->resolve(result); });
+      }
+    }();
+    auto catchCallback = JSIConverter<std::function<void(std::exception_ptr)>>::toJSI(
+        runtime, [=](const std::exception_ptr& exception) { promise->reject(exception); });
+
+    // Chain .then listeners on JS Promise (onResolved and onRejected)
+    jsi::Object jsPromise = value.asObject(runtime);
+    jsi::Function thenFn = jsPromise.getPropertyAsFunction(runtime, "then");
+    thenFn.callWithThis(runtime, jsPromise, thenCallback, catchCallback);
+
+    return promise;
+  }
+
+  static inline jsi::Value toJSI(jsi::Runtime& runtime, const std::shared_ptr<Promise<TResult>>& promise) {
+    if (promise->isPending()) {
+      // Get Promise ctor from global
+      jsi::Function promiseCtor = runtime.global().getPropertyAsFunction(runtime, "Promise");
+      jsi::HostFunctionType executor = [promise](jsi::Runtime& runtime, const jsi::Value&, const jsi::Value* arguments,
+                                                 size_t) -> jsi::Value {
+        // Add resolver listener
+        if constexpr (std::is_void_v<TResult>) {
+          // It's resolving to void.
+          auto resolver = JSIConverter<std::function<void()>>::fromJSI(runtime, arguments[0]);
+          promise->addOnResolvedListener(std::move(resolver));
+        } else {
+          // It's a type.
+          auto resolver = JSIConverter<std::function<void(TResult)>>::fromJSI(runtime, arguments[0]);
+          promise->addOnResolvedListener(std::move(resolver));
+        }
+        // Add rejecter listener
+        auto rejecter = JSIConverter<std::function<void(std::exception_ptr)>>::fromJSI(runtime, arguments[1]);
+        promise->addOnRejectedListener(std::move(rejecter));
+
+        return jsi::Value::undefined();
+      };
+      // Call `Promise` constructor (aka create promise), and pass `executor` function
+      return promiseCtor.callAsConstructor(
+          runtime, jsi::Function::createFromHostFunction(runtime, jsi::PropNameID::forUtf8(runtime, "executor"), 2, executor));
+    } else if (promise->isResolved()) {
+      // Promise is already resolved - just return immediately
+      jsi::Object promiseObject = runtime.global().getPropertyAsObject(runtime, "Promise");
+      jsi::Function createResolvedPromise = promiseObject.getPropertyAsFunction(runtime, "resolve");
+      if constexpr (std::is_void_v<TResult>) {
+        // It's resolving to void.
+        return createResolvedPromise.call(runtime);
+      } else {
+        // It's resolving to a type.
+        jsi::Value result = JSIConverter<TResult>::toJSI(runtime, promise->getResult());
+        return createResolvedPromise.call(runtime, std::move(result));
+      }
+    } else if (promise->isRejected()) {
+      // Promise is already rejected - just return immediately
+      jsi::Object promiseObject = runtime.global().getPropertyAsObject(runtime, "Promise");
+      jsi::Function createRejectedPromise = promiseObject.getPropertyAsFunction(runtime, "reject");
+      jsi::Value error = JSIConverter<std::exception_ptr>::toJSI(runtime, promise->getError());
+      return createRejectedPromise.call(runtime, std::move(error));
+    } else {
+      std::string typeName = TypeInfo::getFriendlyTypename<TResult>(true);
+      throw std::runtime_error("Promise<" + typeName + "> has invalid state!");
+    }
+  }
+
+  static inline bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) {
+    if (!value.isObject()) {
+      return false;
+    }
+    jsi::Object object = value.getObject(runtime);
+    jsi::Function promiseCtor = runtime.global().getPropertyAsFunction(runtime, "Promise");
+    return object.instanceOf(runtime, promiseCtor);
+  }
+};
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JSIConverter+Tuple.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JSIConverter+Tuple.hpp
new file mode 100644
index 0000000..5930e43
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JSIConverter+Tuple.hpp
@@ -0,0 +1,93 @@
+//
+// Created by Marc Rousavy on 21.02.24.
+//
+
+#pragma once
+
+// Forward declare a few of the common types that might have cyclic includes.
+namespace margelo::nitro {
+template <typename T, typename Enable>
+struct JSIConverter;
+} // namespace margelo::nitro
+
+#include "JSIConverter.hpp"
+
+#include "NitroTypeInfo.hpp"
+#include <jsi/jsi.h>
+#include <memory>
+#include <tuple>
+
+namespace margelo::nitro {
+
+using namespace facebook;
+
+// std::tuple<A, B, C> <> [A, B, C]
+template <typename... Types>
+struct JSIConverter<std::tuple<Types...>> final {
+  static inline std::tuple<Types...> fromJSI(jsi::Runtime& runtime, const jsi::Value& value) {
+    jsi::Object object = value.asObject(runtime);
+    jsi::Array array = object.asArray(runtime);
+    if (array.size(runtime) != sizeof...(Types)) [[unlikely]] {
+      std::string types = TypeInfo::getFriendlyTypenames<Types...>();
+      throw std::length_error("The given JS Array has " + std::to_string(array.size(runtime)) + " items, but std::tuple<" + types +
+                              "> expects " + std::to_string(sizeof...(Types)) + " items.");
+    }
+
+    return copyArrayItemsToTuple(runtime, array, std::index_sequence_for<Types...>{});
+  }
+
+  static inline jsi::Value toJSI(jsi::Runtime& runtime, const std::tuple<Types...>& tuple) {
+    jsi::Array array(runtime, sizeof...(Types));
+    copyTupleItemsToArray(runtime, array, tuple, std::index_sequence_for<Types...>{});
+    return array;
+  }
+
+  static inline bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) {
+    if (!value.isObject()) {
+      return false;
+    }
+    jsi::Object object = value.getObject(runtime);
+    if (!object.isArray(runtime)) {
+      return false;
+    }
+    jsi::Array array = object.getArray(runtime);
+    size_t size = array.size(runtime);
+    if (size != sizeof...(Types)) {
+      return false;
+    }
+
+    return canConvertRecursive<Types...>(runtime, array, 0);
+  }
+
+private:
+  template <std::size_t... Is>
+  static inline std::tuple<Types...> copyArrayItemsToTuple(jsi::Runtime& runtime, const jsi::Array& array, std::index_sequence<Is...>) {
+    return std::make_tuple(JSIConverter<Types>::fromJSI(runtime, array.getValueAtIndex(runtime, Is))...);
+  }
+
+  template <std::size_t... Is>
+  static inline void copyTupleItemsToArray(jsi::Runtime& runtime, jsi::Array& array, const std::tuple<Types...>& tuple,
+                                           std::index_sequence<Is...>) {
+    ((array.setValueAtIndex(runtime, Is,
+                            JSIConverter<std::tuple_element_t<Is, std::tuple<Types...>>>::toJSI(runtime, std::get<Is>(tuple)))),
+     ...);
+  }
+
+  template <typename T>
+  static bool canConvertElement(jsi::Runtime& runtime, const jsi::Array& array, size_t index) {
+    return JSIConverter<T>::canConvert(runtime, array.getValueAtIndex(runtime, index));
+  }
+
+  template <typename First, typename... Rest>
+  static bool canConvertRecursive(jsi::Runtime& runtime, const jsi::Array& array, size_t index) {
+    if (!canConvertElement<First>(runtime, array, index)) {
+      return false;
+    }
+    if constexpr (sizeof...(Rest) > 0) {
+      return canConvertRecursive<Rest...>(runtime, array, index + 1);
+    }
+    return true;
+  }
+};
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JSIConverter+UnorderedMap.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JSIConverter+UnorderedMap.hpp
new file mode 100644
index 0000000..666dba9
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JSIConverter+UnorderedMap.hpp
@@ -0,0 +1,70 @@
+//
+// Created by Marc Rousavy on 21.02.24.
+//
+
+#pragma once
+
+// Forward declare a few of the common types that might have cyclic includes.
+namespace margelo::nitro {
+template <typename T, typename Enable>
+struct JSIConverter;
+} // namespace margelo::nitro
+
+#include "JSIConverter.hpp"
+
+#include "AnyMap.hpp"
+#include "JSIHelpers.hpp"
+#include <jsi/jsi.h>
+#include <unordered_map>
+
+namespace margelo::nitro {
+
+using namespace facebook;
+
+// std::unordered_map<std::string, T> <> Record<string, T>
+template <typename ValueType>
+struct JSIConverter<std::unordered_map<std::string, ValueType>> final {
+  static inline std::unordered_map<std::string, ValueType> fromJSI(jsi::Runtime& runtime, const jsi::Value& arg) {
+    jsi::Object object = arg.asObject(runtime);
+    jsi::Array propertyNames = object.getPropertyNames(runtime);
+    size_t length = propertyNames.size(runtime);
+
+    std::unordered_map<std::string, ValueType> map;
+    map.reserve(length);
+    for (size_t i = 0; i < length; ++i) {
+      std::string key = propertyNames.getValueAtIndex(runtime, i).asString(runtime).utf8(runtime);
+      jsi::Value value = object.getProperty(runtime, key.c_str());
+      map.emplace(key, JSIConverter<ValueType>::fromJSI(runtime, value));
+    }
+    return map;
+  }
+  static inline jsi::Value toJSI(jsi::Runtime& runtime, const std::unordered_map<std::string, ValueType>& map) {
+    jsi::Object object(runtime);
+    for (const auto& pair : map) {
+      jsi::Value value = JSIConverter<ValueType>::toJSI(runtime, pair.second);
+      object.setProperty(runtime, pair.first.c_str(), std::move(value));
+    }
+    return object;
+  }
+
+  static inline bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) {
+    if (!value.isObject()) {
+      return false;
+    }
+    jsi::Object object = value.getObject(runtime);
+    if (!isPlainObject(runtime, object)) {
+      return false;
+    }
+    jsi::Array properties = object.getPropertyNames(runtime);
+    size_t size = properties.size(runtime);
+    for (size_t i = 0; i < size; i++) {
+      bool canConvertProp = JSIConverter<ValueType>::canConvert(runtime, properties.getValueAtIndex(runtime, i));
+      if (!canConvertProp) {
+        return false;
+      }
+    }
+    return true;
+  }
+};
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JSIConverter+Variant.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JSIConverter+Variant.hpp
new file mode 100644
index 0000000..e54357a
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JSIConverter+Variant.hpp
@@ -0,0 +1,67 @@
+//
+// Created by Marc Rousavy on 21.02.24.
+//
+
+#pragma once
+
+// Forward declare a few of the common types that might have cyclic includes.
+namespace margelo::nitro {
+struct AnyValue;
+class AnyMap;
+
+template <typename T, typename Enable>
+struct JSIConverter;
+} // namespace margelo::nitro
+
+#include "JSIConverter+UnorderedMap.hpp"
+#include "JSIConverter+Vector.hpp"
+#include "JSIConverter.hpp"
+
+#include "AnyMap.hpp"
+#include "NitroTypeInfo.hpp"
+#include <jsi/jsi.h>
+#include <memory>
+#include <variant>
+
+namespace margelo::nitro {
+
+using namespace facebook;
+
+// std::variant<A, B, C> <> A | B | C
+template <typename... Types>
+struct JSIConverter<std::variant<Types...>> final {
+  static inline bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) {
+    // Check each type in `Types...` to make sure we can convert `jsi::Value` to one of those.
+    return (JSIConverter<Types>::canConvert(runtime, value) || ...);
+  }
+
+  static inline std::variant<Types...> fromJSI(jsi::Runtime& runtime, const jsi::Value& value) {
+    return fromJSIRecursive<Types...>(runtime, value);
+  }
+
+  static inline jsi::Value toJSI(jsi::Runtime& runtime, const std::variant<Types...>& variant) {
+    return std::visit(
+        [&runtime](const auto& val) {
+          // Try to convert each type
+          return JSIConverter<std::decay_t<decltype(val)>>::toJSI(runtime, val);
+        },
+        variant);
+  }
+
+private:
+  template <typename First, typename... Rest>
+  static inline std::variant<Types...> fromJSIRecursive(jsi::Runtime& runtime, const jsi::Value& value) {
+    if (JSIConverter<First>::canConvert(runtime, value)) {
+      return JSIConverter<First>::fromJSI(runtime, value);
+    }
+    if constexpr (sizeof...(Rest) == 0) {
+      std::string string = value.toString(runtime).utf8(runtime);
+      std::string types = TypeInfo::getFriendlyTypenames<Types...>();
+      throw std::runtime_error("Cannot convert \"" + string + "\" to any type in variant<" + types + ">!");
+    } else {
+      return fromJSIRecursive<Rest...>(runtime, value);
+    }
+  }
+};
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JSIConverter+Vector.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JSIConverter+Vector.hpp
new file mode 100644
index 0000000..4cefdb0
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JSIConverter+Vector.hpp
@@ -0,0 +1,69 @@
+//
+// Created by Marc Rousavy on 21.02.24.
+//
+
+#pragma once
+
+// Forward declare a few of the common types that might have cyclic includes.
+namespace margelo::nitro {
+template <typename T, typename Enable>
+struct JSIConverter;
+} // namespace margelo::nitro
+
+#include "JSIConverter.hpp"
+
+#include "AnyMap.hpp"
+#include <jsi/jsi.h>
+#include <vector>
+
+namespace margelo::nitro {
+
+using namespace facebook;
+
+// std::vector<T> <> T[]
+template <typename ElementType>
+struct JSIConverter<std::vector<ElementType>> final {
+  static inline std::vector<ElementType> fromJSI(jsi::Runtime& runtime, const jsi::Value& arg) {
+    jsi::Array array = arg.asObject(runtime).asArray(runtime);
+    size_t length = array.size(runtime);
+
+    std::vector<ElementType> vector;
+    vector.reserve(length);
+    for (size_t i = 0; i < length; ++i) {
+      jsi::Value elementValue = array.getValueAtIndex(runtime, i);
+      vector.emplace_back(JSIConverter<ElementType>::fromJSI(runtime, elementValue));
+    }
+    return vector;
+  }
+  static inline jsi::Value toJSI(jsi::Runtime& runtime, const std::vector<ElementType>& vector) {
+    jsi::Array array(runtime, vector.size());
+    for (size_t i = 0; i < vector.size(); i++) {
+      jsi::Value value = JSIConverter<ElementType>::toJSI(runtime, vector[i]);
+      array.setValueAtIndex(runtime, i, std::move(value));
+    }
+    return array;
+  }
+
+  static inline bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) {
+    if (!value.isObject()) {
+      return false;
+    }
+    jsi::Object object = value.getObject(runtime);
+    if (!object.isArray(runtime)) {
+      return false;
+    }
+    jsi::Array array = object.getArray(runtime);
+    if (array.size(runtime) == 0) {
+      // it is an empty array, so it _theoretically_ doesn't matter what type it holds. Just say true.
+      return true;
+    }
+    // Check the type of the first element in the array.
+    // Technically the array can also have different types for each item,
+    // and to be absolutely sure that we can convert the entire array, we have to check each item in the array.
+    // But we don't want to do that for performance reasons - let's just assume the user doesn't make this mistake.
+    jsi::Value firstElement = array.getValueAtIndex(runtime, 0);
+    return JSIConverter<ElementType>::canConvert(runtime, firstElement);
+  }
+};
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JSIConverter.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JSIConverter.hpp
new file mode 100644
index 0000000..cc4d94b
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JSIConverter.hpp
@@ -0,0 +1,197 @@
+//
+// Created by Marc Rousavy on 21.02.24.
+//
+
+#pragma once
+
+// Forward declare a few of the common types that might have cyclic includes.
+namespace margelo::nitro {
+template <typename T, typename Enable>
+struct JSIConverter;
+} // namespace margelo::nitro
+
+#include <jsi/jsi.h>
+#include <type_traits>
+#include <variant>
+
+namespace margelo::nitro {
+
+using namespace facebook;
+
+/**
+ * The JSIConverter<T> class can convert any type from and to a jsi::Value.
+ * It uses templates to statically create fromJSI/toJSI methods, and will throw compile-time errors
+ * if a given type is not convertable.
+ * Value types, custom types (HybridObject), and even functions with any number of arguments/types are supported.
+ * This type can be extended by just creating a new template for JSIConverter in a header.
+ */
+template <typename T, typename Enable = void>
+struct JSIConverter final {
+  JSIConverter() = delete;
+
+  /**
+   * Converts the given `jsi::Value` to type `T`.
+   * By default, this static-asserts.
+   */
+  static inline T fromJSI(jsi::Runtime&, const jsi::Value&) {
+    static_assert(always_false<T>::value, "This type is not supported by the JSIConverter!");
+    return T();
+  }
+  /**
+   * Converts `T` to a `jsi::Value`.
+   * By default, this static-asserts.
+   */
+  static inline jsi::Value toJSI(jsi::Runtime&, T) {
+    static_assert(always_false<T>::value, "This type is not supported by the JSIConverter!");
+    return jsi::Value::undefined();
+  }
+  /**
+   * Returns whether the given `jsi::Value` can be converted to `T`.
+   * This involves runtime type-checks.
+   * By default, this returns `false`.
+   */
+  static inline bool canConvert(jsi::Runtime&, const jsi::Value&) {
+    return false;
+  }
+
+private:
+  template <typename>
+  struct always_false : std::false_type {};
+};
+
+// int <> number
+template <>
+struct JSIConverter<int> final {
+  static inline int fromJSI(jsi::Runtime&, const jsi::Value& arg) {
+    return static_cast<int>(arg.asNumber());
+  }
+  static inline jsi::Value toJSI(jsi::Runtime&, int arg) {
+    return jsi::Value(arg);
+  }
+  static inline bool canConvert(jsi::Runtime&, const jsi::Value& value) {
+    return value.isNumber();
+  }
+};
+
+// double <> number
+template <>
+struct JSIConverter<double> final {
+  static inline double fromJSI(jsi::Runtime&, const jsi::Value& arg) {
+    return arg.asNumber();
+  }
+  static inline jsi::Value toJSI(jsi::Runtime&, double arg) {
+    return jsi::Value(arg);
+  }
+  static inline bool canConvert(jsi::Runtime&, const jsi::Value& value) {
+    return value.isNumber();
+  }
+};
+
+// float <> number
+template <>
+struct JSIConverter<float> final {
+  static inline float fromJSI(jsi::Runtime&, const jsi::Value& arg) {
+    return static_cast<float>(arg.asNumber());
+  }
+  static inline jsi::Value toJSI(jsi::Runtime&, float arg) {
+    return jsi::Value(static_cast<double>(arg));
+  }
+  static inline bool canConvert(jsi::Runtime&, const jsi::Value& value) {
+    return value.isNumber();
+  }
+};
+
+// int64_t <> BigInt
+template <>
+struct JSIConverter<int64_t> final {
+  static inline double fromJSI(jsi::Runtime& runtime, const jsi::Value& arg) {
+    return arg.asBigInt(runtime).asInt64(runtime);
+  }
+  static inline jsi::Value toJSI(jsi::Runtime& runtime, int64_t arg) {
+    return jsi::BigInt::fromInt64(runtime, arg);
+  }
+  static inline bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) {
+    if (value.isBigInt()) {
+      jsi::BigInt bigint = value.getBigInt(runtime);
+      return bigint.isInt64(runtime);
+    }
+    return false;
+  }
+};
+
+// uint64_t <> BigInt
+template <>
+struct JSIConverter<uint64_t> final {
+  static inline double fromJSI(jsi::Runtime& runtime, const jsi::Value& arg) {
+    return arg.asBigInt(runtime).asUint64(runtime);
+  }
+  static inline jsi::Value toJSI(jsi::Runtime& runtime, uint64_t arg) {
+    return jsi::BigInt::fromUint64(runtime, arg);
+  }
+  static inline bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) {
+    if (value.isBigInt()) {
+      jsi::BigInt bigint = value.getBigInt(runtime);
+      return bigint.isUint64(runtime);
+    }
+    return false;
+  }
+};
+
+// bool <> boolean
+template <>
+struct JSIConverter<bool> final {
+  static inline bool fromJSI(jsi::Runtime&, const jsi::Value& arg) {
+    return arg.asBool();
+  }
+  static inline jsi::Value toJSI(jsi::Runtime&, bool arg) {
+    return jsi::Value(arg);
+  }
+  static inline bool canConvert(jsi::Runtime&, const jsi::Value& value) {
+    return value.isBool();
+  }
+};
+
+// std::string <> string
+template <>
+struct JSIConverter<std::string> final {
+  static inline std::string fromJSI(jsi::Runtime& runtime, const jsi::Value& arg) {
+    return arg.asString(runtime).utf8(runtime);
+  }
+  static inline jsi::Value toJSI(jsi::Runtime& runtime, const std::string& arg) {
+    return jsi::String::createFromUtf8(runtime, arg);
+  }
+  static inline bool canConvert(jsi::Runtime&, const jsi::Value& value) {
+    return value.isString();
+  }
+};
+
+// std::monostate <> void/undefined
+template <>
+struct JSIConverter<std::monostate> final {
+  static inline std::monostate fromJSI(jsi::Runtime&, const jsi::Value&) {
+    return std::monostate{};
+  }
+  static inline jsi::Value toJSI(jsi::Runtime&, std::monostate) {
+    return jsi::Value();
+  }
+  static inline bool canConvert(jsi::Runtime&, const jsi::Value&) {
+    return true;
+  }
+};
+
+} // namespace margelo::nitro
+
+#include "JSIConverter+AnyMap.hpp"
+#include "JSIConverter+ArrayBuffer.hpp"
+#include "JSIConverter+Date.hpp"
+#include "JSIConverter+Exception.hpp"
+#include "JSIConverter+Function.hpp"
+#include "JSIConverter+HostObject.hpp"
+#include "JSIConverter+NativeState.hpp"
+#include "JSIConverter+Null.hpp"
+#include "JSIConverter+Optional.hpp"
+#include "JSIConverter+Promise.hpp"
+#include "JSIConverter+Tuple.hpp"
+#include "JSIConverter+UnorderedMap.hpp"
+#include "JSIConverter+Variant.hpp"
+#include "JSIConverter+Vector.hpp"
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JSIHelpers.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JSIHelpers.hpp
new file mode 100644
index 0000000..6049dfd
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JSIHelpers.hpp
@@ -0,0 +1,52 @@
+//
+//  JSIHelpers.hpp
+//  Nitro
+//
+//  Created by Marc Rousavy on 07.08.24.
+//
+
+#pragma once
+
+#include "ThreadUtils.hpp"
+#include <jsi/jsi.h>
+
+namespace margelo::nitro {
+
+using namespace facebook;
+
+/**
+ * Returns whether the given `jsi::Object` is a plain-JS object, or not.
+ * If it is not a plain-JS object, it could be an Array, ArrayBuffer, Function,
+ * HostObject or NativeState.
+ */
+static inline bool isPlainObject(jsi::Runtime& runtime, const jsi::Object& object) {
+  if (object.isArray(runtime)) {
+    return false;
+  }
+  if (object.isArrayBuffer(runtime)) {
+    return false;
+  }
+  if (object.isFunction(runtime)) {
+    return false;
+  }
+  if (object.isHostObject(runtime)) {
+    return false;
+  }
+  if (object.hasNativeState(runtime)) {
+    return false;
+  }
+  return true;
+}
+
+/**
+ * Get an ID for the given Runtime.
+ *
+ * The ID usually consists of a Runtime description (e.g. "HermesRuntime"),
+ * and it's Thread (e.g. "com.facebook.react.runtime.JavaScript")
+ */
+static inline std::string getRuntimeId(jsi::Runtime& runtime) {
+  std::string threadName = ThreadUtils::getThreadName();
+  return runtime.description() + " (" + threadName + ")";
+}
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JStateWrapper.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JStateWrapper.hpp
new file mode 100644
index 0000000..4571fd6
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JStateWrapper.hpp
@@ -0,0 +1,22 @@
+//
+// Created by Hanno Gdecke on 09.05.2025.
+//
+
+#pragma once
+
+#include <fbjni/fbjni.h>
+
+namespace margelo::nitro {
+
+using namespace facebook;
+
+/**
+ * C++ counterpart for the StateWrapper java class which is exposed in the fabric view manager implementation.
+ * Internally fabric is using StateWrapperImpl.kt but this class is hidden.
+ * We thus pass the StateWrapper typed object to the native side and on the c++ side we can cast it to a StateWrapperImpl type.
+ */
+struct JStateWrapper : public jni::JavaClass<JStateWrapper> {
+  static constexpr auto kJavaDescriptor = "Lcom/facebook/react/uimanager/StateWrapper;";
+};
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JUnit.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JUnit.hpp
new file mode 100644
index 0000000..ff76872
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/JUnit.hpp
@@ -0,0 +1,38 @@
+//
+//  JUnit.hpp
+//  react-native-nitro
+//
+//  Created by Marc Rousavy on 19.11.24.
+//
+
+#pragma once
+
+#include "NitroDefines.hpp"
+#include <fbjni/fbjni.h>
+
+namespace margelo::nitro {
+
+using namespace facebook;
+
+/**
+ * Represents a `Unit` from Kotlin.
+ * This is similar to `void` for Java, but is actually an `Object`.
+ */
+class JUnit final {
+public:
+  /**
+   * Gets the shared instance to `Unit`. This is always a static global.
+   */
+  static jni::alias_ref<jni::JObject> instance() {
+    static jni::global_ref<jni::JObject> sharedInstance = nullptr;
+    if (sharedInstance == nullptr) {
+      jni::alias_ref<jni::JClass> clazz = jni::findClassStatic("java/lang/Object");
+      jni::JConstructor<jobject()> constructor = clazz->getConstructor<jobject()>();
+      jni::local_ref<jobject> instance = clazz->newObject(constructor);
+      sharedInstance = jni::make_global(instance);
+    }
+    return sharedInstance;
+  }
+};
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/NitroDefines.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/NitroDefines.hpp
new file mode 100644
index 0000000..dd0ad45
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/NitroDefines.hpp
@@ -0,0 +1,73 @@
+//
+//  NitroDefines.hpp
+//  Nitro
+//
+//  Created by Marc Rousavy on 29.07.24.
+//
+
+#ifndef NitroDefines_h
+#define NitroDefines_h
+
+// Sets the version of the native Nitro core library
+#define NITRO_VERSION "0.31.10"
+
+// Sets whether to use debug or optimized production build flags
+#ifdef DEBUG
+#define NITRO_DEBUG
+#endif
+#ifdef NDEBUG
+#undef NITRO_DEBUG
+#endif
+#ifdef ANDROID
+#ifndef NDEBUG
+#define NITRO_DEBUG
+#endif
+#endif
+
+// Helper to find out if a C++ compiler attribute is available
+#ifdef __has_attribute
+#define _CXX_INTEROP_HAS_ATTRIBUTE(x) __has_attribute(x)
+#else
+#define _CXX_INTEROP_HAS_ATTRIBUTE(x) 0
+#endif
+
+// Closed/Final Enums
+#if _CXX_INTEROP_HAS_ATTRIBUTE(enum_extensibility)
+// Enum is marked as closed/not extensible
+#define CLOSED_ENUM __attribute__((enum_extensibility(closed)))
+#else
+#define CLOSED_ENUM
+#endif
+
+// Nullability
+#if defined(__clang__)
+#define NON_NULL _Nonnull
+#define NULLABLE _Nullable
+#else
+#define NON_NULL
+#define NULLABLE
+#endif
+
+// Contiguous memory in pointers (__restrict)
+#if defined(__clang__)
+#define CONTIGUOUS_MEMORY __restrict__
+#elif defined(_MSC_VER)
+#define CONTIGUOUS_MEMORY __restrict
+#else
+#define CONTIGUOUS_MEMORY
+#endif
+
+// Swift Support
+#if __has_include(<swift/bridging>)
+// Swift's bridging header defines those things
+#include <swift/bridging>
+#define SWIFT_PRIVATE __attribute__((swift_private))
+#else
+// If we don't have Swift bridging header, those macros do nothing
+#define SWIFT_NAME(_name)
+#define SWIFT_PRIVATE
+#define SWIFT_COMPUTED_PROPERTY
+#define SWIFT_NONCOPYABLE
+#endif
+
+#endif /* NitroDefines_h */
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/NitroHash.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/NitroHash.hpp
new file mode 100644
index 0000000..10f9884
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/NitroHash.hpp
@@ -0,0 +1,61 @@
+//
+//  NitroHash.hpp
+//  react-native-nitro
+//
+//  Created by Marc Rousavy on 14.07.24.
+//
+
+#pragma once
+
+#include "NitroDefines.hpp"
+#include <cstddef>
+#include <cstdint>
+#include <string>
+
+namespace margelo::nitro {
+
+/**
+ * Hashes the given C-String using the FNV-1a hashing algorithm.
+ *
+ * This function can be used at compile time as a constexpr to build
+ * statically optimized switch statements.
+ */
+constexpr uint64_t hashString(const char* NON_NULL str, size_t length) {
+  uint64_t hash = 14695981039346656037ull; // FNV offset basis
+  const uint64_t fnv_prime = 1099511628211ull;
+
+  for (size_t i = 0; i < length; ++i) {
+    hash ^= static_cast<uint64_t>(str[i]);
+    hash *= fnv_prime;
+  }
+
+  return hash;
+}
+
+/**
+ * Hashes the given constant C-String using the FNV-1a hashing algorithm.
+ *
+ * String length is known at compile time.
+ */
+template <size_t N>
+constexpr uint64_t hashString(const char (&str)[N]) {
+  return hashString(str, N - 1); // N includes the null terminator, so subtract 1
+}
+
+/**
+ * Hashes the given `string_view` using the FNV-1a hashing algorithm.
+ * This can be constexpr.
+ */
+constexpr uint64_t hashString(const std::string_view& string) {
+  return hashString(string.data(), string.length());
+}
+
+/**
+ * Hashes the given `string` using the FNV-1a hashing algorithm.
+ * This happens at runtime.
+ */
+inline uint64_t hashString(const std::string& string) {
+  return hashString(string.c_str(), string.length());
+}
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/NitroLogger.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/NitroLogger.hpp
new file mode 100644
index 0000000..86b3631
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/NitroLogger.hpp
@@ -0,0 +1,69 @@
+//
+// Created by Marc Rousavy on 05.03.24.
+//
+
+#pragma once
+
+#include "NitroDefines.hpp"
+#include <cstdarg>
+#include <cstdio>
+#include <iostream>
+#include <sstream>
+#include <string>
+#include <type_traits>
+
+namespace margelo::nitro {
+
+enum class LogLevel { Debug, Info, Warning, Error };
+
+class Logger final {
+private:
+  Logger() = delete;
+
+public:
+  template <typename... Args>
+  static void log([[maybe_unused]] LogLevel level, [[maybe_unused]] const char* NON_NULL tag, [[maybe_unused]] const char* NON_NULL format,
+                  [[maybe_unused]] Args... args) {
+#ifdef NITRO_DEBUG
+    // 1. Make sure args can be passed to sprintf(..)
+    static_assert(all_are_trivially_copyable<Args...>(), "All arguments passed to Logger::log(..) must be trivially copyable! "
+                                                         "Did you try to pass a complex type, like std::string?");
+
+    // 2. Format all arguments in the message
+    std::string message = formatString(format, args...);
+
+    // 3. Call the platform specific log function
+    nativeLog(level, tag, message);
+#endif
+  }
+
+  static void nativeLog(LogLevel level, const char* NON_NULL tag, const std::string& string);
+
+private:
+  template <typename... Args>
+  static std::string formatString(const char* NON_NULL format, Args... args) {
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wformat-security"
+    int size = snprintf(nullptr, 0, format, args...) + 1; // Extra space for '\0'
+    if (size <= 0) {
+      return "Error during formatting.";
+    }
+    std::unique_ptr<char[]> buf(new char[size]);
+    snprintf(buf.get(), size, format, args...);
+    return std::string(buf.get(), buf.get() + size - 1); // We don't want the '\0' inside
+#pragma clang diagnostic pop
+  }
+
+  // Overloaded functions to convert std::string to C-style string
+  template <typename T>
+  static constexpr bool is_trivially_copyable() {
+    return std::is_trivially_copyable<T>::value;
+  }
+
+  template <typename... Args>
+  static constexpr bool all_are_trivially_copyable() {
+    return (is_trivially_copyable<Args>() && ...);
+  }
+};
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/NitroTypeInfo.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/NitroTypeInfo.hpp
new file mode 100644
index 0000000..128b807
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/NitroTypeInfo.hpp
@@ -0,0 +1,66 @@
+//
+//  NitroTypeInfo.hpp
+//  Nitro
+//
+//  Created by Marc Rousavy on 17.07.24.
+//
+
+#pragma once
+
+#include "NitroDefines.hpp"
+#include <regex>
+#include <sstream>
+#include <string>
+#include <type_traits>
+#include <typeindex>
+
+namespace margelo::nitro {
+
+struct TypeInfo final {
+public:
+  TypeInfo() = delete;
+
+  /**
+   * Get the name of the currently thrown exception
+   */
+  static std::string getCurrentExceptionName();
+
+  /**
+   * Get a friendly name of the given `type_info` (if possible, demangled)
+   */
+  static inline std::string getFriendlyTypename(const std::type_info& type, bool removeNamespace = false) {
+    std::string typeName = type.name();
+    return demangleName(typeName, removeNamespace);
+  }
+
+  /**
+   * Get a friendly name of the given `type_index` (if possible, demangled)
+   */
+  static inline std::string getFriendlyTypename(const std::type_index& typeIndex, bool removeNamespace = false) {
+    std::string typeName = typeIndex.name();
+    return demangleName(typeName, removeNamespace);
+  }
+
+  /**
+   * Get a friendly name of the type `T` (if possible, demangled)
+   */
+  template <typename T>
+  static inline std::string getFriendlyTypename(bool removeNamespace = false) {
+    return getFriendlyTypename(typeid(T), removeNamespace);
+  }
+
+  template <typename... Types>
+  static inline std::string getFriendlyTypenames(bool removeNamespace = false) {
+    std::ostringstream stream;
+    ((stream << TypeInfo::getFriendlyTypename<Types>(removeNamespace) << ", "), ...);
+    std::string string = stream.str();
+    return string.substr(0, string.length() - 2);
+  }
+
+private:
+  static std::string replaceRegex(const std::string& original, const std::string& pattern, const std::string& replacement);
+
+  static std::string demangleName(const std::string& typeName, bool removeNamespace = false);
+};
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/Null.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/Null.hpp
new file mode 100644
index 0000000..66979f5
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/Null.hpp
@@ -0,0 +1,42 @@
+//
+// Created by Marc Rousavy on 30.07.24.
+//
+
+#pragma once
+
+#include "NitroDefines.hpp"
+#include <functional>
+#include <type_traits>
+
+namespace margelo::nitro {
+
+/**
+ * Represents the type of `null` - which should always be a singleton.
+ */
+enum class NullType { null };
+
+/**
+ * Represents an explicit `null` from JS.
+ * This is a singleton.
+ */
+inline constexpr NullType null = NullType::null;
+
+// Equality and ordering: all instances are equal
+constexpr bool operator==(NullType, NullType) noexcept {
+  return true;
+}
+constexpr bool operator!=(NullType, NullType) noexcept {
+  return false;
+}
+
+} // namespace margelo::nitro
+
+// Makes nitro::Null hashable
+namespace std {
+template <>
+struct hash<margelo::nitro::NullType> {
+  size_t operator()(margelo::nitro::NullType) const noexcept {
+    return 0;
+  }
+};
+} // namespace std
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/ObjectUtils.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/ObjectUtils.hpp
new file mode 100644
index 0000000..864e6e1
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/ObjectUtils.hpp
@@ -0,0 +1,94 @@
+//
+//  ObjectUtils.hpp
+//  react-native-nitro
+//
+//  Created by Marc Rousavy on 17.10.25.
+//
+
+#pragma once
+
+#include "BorrowingReference.hpp"
+#include <jsi/jsi.h>
+#include <unordered_map>
+
+namespace margelo::nitro {
+
+using namespace facebook;
+
+struct PlainPropertyDescriptor {
+  bool configurable;
+  bool enumerable;
+  jsi::Value value;
+  bool writable;
+};
+struct ComputedReadonlyPropertyDescriptor {
+  bool configurable;
+  bool enumerable;
+  jsi::Function get;
+};
+struct ComputedPropertyDescriptor {
+  bool configurable;
+  bool enumerable;
+  jsi::Function get;
+  jsi::Function set;
+};
+
+enum class KnownGlobalPropertyName { DISPATCHER, JSI_CACHE, NITRO_MODULES_PROXY };
+
+class ObjectUtils {
+public:
+  ObjectUtils() = delete;
+  ~ObjectUtils() = delete;
+
+public:
+  /**
+   * Create a new `jsi::Object` with the given `prototype`.
+   * Uses a native implementation if possible.
+   */
+  static jsi::Object create(jsi::Runtime& runtime, const jsi::Value& prototype, bool allowCache = true);
+
+  /**
+   * Define a global value for the given Runtime.
+   * In debug, this performs additional safety checks such as freezing the property.
+   */
+  static void defineGlobal(jsi::Runtime& runtime, KnownGlobalPropertyName name, jsi::Value&& value, bool allowCache = true);
+
+  /**
+   * Define a plain property on the given `object` with the given `propertyName`.
+   * The `descriptor` defines the attributes of this property.
+   */
+  static void defineProperty(jsi::Runtime& runtime, const jsi::Object& object, const char* propertyName,
+                             PlainPropertyDescriptor&& descriptor, bool allowCache = true);
+  /**
+   * Define a plain property on the given `object` with the given `propertyName`.
+   * The `descriptor` defines the attributes of this property.
+   */
+  static void defineProperty(jsi::Runtime& runtime, const jsi::Object& object, const char* propertyName,
+                             ComputedReadonlyPropertyDescriptor&& descriptor, bool allowCache = true);
+  /**
+   * Define a plain property on the given `object` with the given `propertyName`.
+   * The `descriptor` defines the attributes of this property.
+   */
+  static void defineProperty(jsi::Runtime& runtime, const jsi::Object& object, const char* propertyName,
+                             ComputedPropertyDescriptor&& descriptor, bool allowCache = true);
+
+  /**
+   * Freezes all values of the given `object`.
+   */
+  static void freeze(jsi::Runtime& runtime, const jsi::Object& object, bool allowCache = true);
+
+  /**
+   * Get a string name for a known global property name.
+   */
+  static const char* getKnownGlobalPropertyNameString(KnownGlobalPropertyName name);
+
+private:
+  using FunctionCache = std::unordered_map<std::string, BorrowingReference<jsi::Function>>;
+  static std::unordered_map<jsi::Runtime*, FunctionCache> _cache;
+
+  static BorrowingReference<jsi::Function> getGlobalFunction(jsi::Runtime& runtime, const char* key,
+                                                             std::function<jsi::Function(jsi::Runtime&)> getFunction,
+                                                             bool allowCache = true);
+};
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/Promise.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/Promise.hpp
new file mode 100644
index 0000000..758aa39
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/Promise.hpp
@@ -0,0 +1,324 @@
+//
+// Created by Marc Rousavy on 18.11.24.
+//
+
+#pragma once
+
+#include "AssertPromiseState.hpp"
+#include "NitroDefines.hpp"
+#include "NitroTypeInfo.hpp"
+#include "ThreadPool.hpp"
+#include <exception>
+#include <future>
+#include <jsi/jsi.h>
+#include <memory>
+#include <mutex>
+#include <variant>
+
+namespace margelo::nitro {
+
+using namespace facebook;
+
+template <typename TResult>
+class Promise final {
+public:
+  using OnResolvedFunc = std::function<void(const TResult&)>;
+  using OnRejectedFunc = std::function<void(const std::exception_ptr&)>;
+
+public:
+  // Promise cannot be copied.
+  Promise(const Promise&) = delete;
+
+private:
+  Promise() = default;
+
+public:
+  ~Promise() {
+    if (isPending()) [[unlikely]] {
+      auto message = std::string("Timeouted: Promise<") + TypeInfo::getFriendlyTypename<TResult>() + "> was destroyed!";
+      reject(std::make_exception_ptr(std::runtime_error(message)));
+    }
+  }
+
+public:
+  /**
+   * Creates a new pending Promise that has to be resolved
+   * or rejected with `resolve(..)` or `reject(..)`.
+   */
+  static std::shared_ptr<Promise> create() {
+    return std::shared_ptr<Promise>(new Promise());
+  }
+
+  /**
+   * Creates a Promise that runs the given function `run` on a separate Thread pool.
+   */
+  static std::shared_ptr<Promise> async(std::function<TResult()>&& run) {
+    auto promise = create();
+    ThreadPool::shared().run([run = std::move(run), promise]() {
+      try {
+        // Run the code, then resolve.
+        TResult result = run();
+        promise->resolve(std::move(result));
+      } catch (...) {
+        // It threw an error.
+        promise->reject(std::current_exception());
+      }
+    });
+    return promise;
+  }
+
+  /**
+   * Creates a Promise and awaits the given future on a background Thread.
+   * Once the future resolves or rejects, the Promise resolves or rejects.
+   */
+  static std::shared_ptr<Promise> awaitFuture(std::future<TResult>&& future) {
+    auto sharedFuture = std::make_shared<std::future<TResult>>(std::move(future));
+    return async([sharedFuture = std::move(sharedFuture)]() { return sharedFuture->get(); });
+  }
+
+  /**
+   * Creates an immediately resolved Promise.
+   */
+  static std::shared_ptr<Promise> resolved(TResult&& result) {
+    auto promise = create();
+    promise->resolve(std::move(result));
+    return promise;
+  }
+  /**
+   * Creates an immediately rejected Promise.
+   */
+  static std::shared_ptr<Promise> rejected(const std::exception_ptr& error) {
+    auto promise = create();
+    promise->reject(error);
+    return promise;
+  }
+
+public:
+  /**
+   * Resolves this Promise with the given result, and calls any pending listeners.
+   */
+  void resolve(TResult&& result) {
+    std::unique_lock lock(_mutex);
+#ifdef NITRO_DEBUG
+    assertPromiseState(*this, PromiseTask::WANTS_TO_RESOLVE);
+#endif
+    _state = std::move(result);
+    for (const auto& onResolved : _onResolvedListeners) {
+      onResolved(std::get<TResult>(_state));
+    }
+    didFinish();
+  }
+  void resolve(const TResult& result) {
+    std::unique_lock lock(_mutex);
+#ifdef NITRO_DEBUG
+    assertPromiseState(*this, PromiseTask::WANTS_TO_RESOLVE);
+#endif
+    _state = result;
+    for (const auto& onResolved : _onResolvedListeners) {
+      onResolved(std::get<TResult>(_state));
+    }
+    didFinish();
+  }
+  /**
+   * Rejects this Promise with the given error, and calls any pending listeners.
+   */
+  void reject(const std::exception_ptr& exception) {
+    if (exception == nullptr) [[unlikely]] {
+      std::string typeName = TypeInfo::getFriendlyTypename<TResult>(true);
+      throw std::runtime_error("Cannot reject Promise<" + typeName + "> with a null exception_ptr!");
+    }
+
+    std::unique_lock lock(_mutex);
+#ifdef NITRO_DEBUG
+    assertPromiseState(*this, PromiseTask::WANTS_TO_REJECT);
+#endif
+    _state = exception;
+    for (const auto& onRejected : _onRejectedListeners) {
+      onRejected(exception);
+    }
+    didFinish();
+  }
+
+public:
+  /**
+   * Add a listener that will be called when the Promise gets resolved.
+   * If the Promise is already resolved, the listener will be immediately called.
+   */
+  void addOnResolvedListener(OnResolvedFunc&& onResolved) {
+    std::unique_lock lock(_mutex);
+    if (std::holds_alternative<TResult>(_state)) {
+      // Promise is already resolved! Call the callback immediately
+      onResolved(std::get<TResult>(_state));
+    } else {
+      // Promise is not yet resolved, put the listener in our queue.
+      _onResolvedListeners.push_back(std::move(onResolved));
+    }
+  }
+  void addOnResolvedListener(const OnResolvedFunc& onResolved) {
+    std::unique_lock lock(_mutex);
+    if (std::holds_alternative<TResult>(_state)) {
+      // Promise is already resolved! Call the callback immediately
+      onResolved(std::get<TResult>(_state));
+    } else {
+      // Promise is not yet resolved, put the listener in our queue.
+      _onResolvedListeners.push_back(onResolved);
+    }
+  }
+
+  /**
+   * Add a listener that will be called when the Promise gets rejected.
+   * If the Promise is already rejected, the listener will be immediately called.
+   */
+  void addOnRejectedListener(OnRejectedFunc&& onRejected) {
+    std::unique_lock lock(_mutex);
+    if (std::holds_alternative<std::exception_ptr>(_state)) {
+      // Promise is already rejected! Call the callback immediately
+      onRejected(std::get<std::exception_ptr>(_state));
+    } else {
+      // Promise is not yet rejected, put the listener in our queue.
+      _onRejectedListeners.push_back(std::move(onRejected));
+    }
+  }
+  void addOnRejectedListener(const OnRejectedFunc& onRejected) {
+    std::unique_lock lock(_mutex);
+    if (std::holds_alternative<std::exception_ptr>(_state)) {
+      // Promise is already rejected! Call the callback immediately
+      onRejected(std::get<std::exception_ptr>(_state));
+    } else {
+      // Promise is not yet rejected, put the listener in our queue.
+      _onRejectedListeners.push_back(onRejected);
+    }
+  }
+
+public:
+  /**
+   * Gets an awaitable `std::future<T>` for this `Promise<T>`.
+   */
+  std::future<TResult> await() {
+    auto promise = std::make_shared<std::promise<TResult>>();
+    addOnResolvedListener([promise](const TResult& result) { promise->set_value(result); });
+    addOnRejectedListener([promise](const std::exception_ptr& error) { promise->set_exception(error); });
+    return promise->get_future();
+  }
+
+public:
+  /**
+   * Get the result of the Promise if it has been resolved.
+   * If the Promise is not resolved, this will throw.
+   */
+  inline const TResult& getResult() {
+    if (!isResolved()) {
+      std::string typeName = TypeInfo::getFriendlyTypename<TResult>(true);
+      throw std::runtime_error("Cannot get result when Promise<" + typeName + "> is not yet resolved!");
+    }
+    return std::get<TResult>(_state);
+  }
+  /**
+   * Get the error of the Promise if it has been rejected.
+   * If the Promise is not rejected, this will throw.
+   */
+  inline const std::exception_ptr& getError() {
+    if (!isRejected()) {
+      std::string typeName = TypeInfo::getFriendlyTypename<TResult>(true);
+      throw std::runtime_error("Cannot get error when Promise<" + typeName + "> is not yet rejected!");
+    }
+    return std::get<std::exception_ptr>(_state);
+  }
+
+public:
+  /**
+   * Gets whether this Promise has been successfully resolved with a result, or not.
+   */
+  [[nodiscard]]
+  inline bool isResolved() const noexcept {
+    return std::holds_alternative<TResult>(_state);
+  }
+  /**
+   * Gets whether this Promise has been rejected with an error, or not.
+   */
+  [[nodiscard]]
+  inline bool isRejected() const noexcept {
+    return std::holds_alternative<std::exception_ptr>(_state);
+  }
+  /**
+   * Gets whether this Promise has not yet been resolved nor rejected.
+   */
+  [[nodiscard]]
+  inline bool isPending() const noexcept {
+    return std::holds_alternative<std::monostate>(_state);
+  }
+
+private:
+  void didFinish() noexcept {
+    _onResolvedListeners.clear();
+    _onRejectedListeners.clear();
+  }
+
+private:
+  std::variant<std::monostate, TResult, std::exception_ptr> _state;
+  std::vector<OnResolvedFunc> _onResolvedListeners;
+  std::vector<OnRejectedFunc> _onRejectedListeners;
+  std::mutex _mutex;
+};
+
+// Specialization for void
+template <>
+class Promise<void> final {
+public:
+  using OnResolvedFunc = std::function<void()>;
+  using OnRejectedFunc = std::function<void(const std::exception_ptr&)>;
+
+public:
+  Promise(const Promise&) = delete;
+  Promise(Promise&&) = delete;
+  ~Promise();
+
+private:
+  Promise() = default;
+
+public:
+  static std::shared_ptr<Promise> create();
+  static std::shared_ptr<Promise> async(std::function<void()>&& run);
+  static std::shared_ptr<Promise> awaitFuture(std::future<void>&& future);
+  static std::shared_ptr<Promise> resolved();
+  static std::shared_ptr<Promise> rejected(const std::exception_ptr& error);
+
+public:
+  void resolve();
+  void reject(const std::exception_ptr& exception);
+
+public:
+  void addOnResolvedListener(OnResolvedFunc&& onResolved);
+  void addOnResolvedListener(const OnResolvedFunc& onResolved);
+  void addOnRejectedListener(OnRejectedFunc&& onRejected);
+  void addOnRejectedListener(const OnRejectedFunc& onRejected);
+
+public:
+  std::future<void> await();
+
+public:
+  const std::exception_ptr& getError();
+
+public:
+  inline bool isResolved() const noexcept {
+    return _isResolved;
+  }
+  inline bool isRejected() const noexcept {
+    return _error != nullptr;
+  }
+  inline bool isPending() const noexcept {
+    return !isResolved() && !isRejected();
+  }
+
+private:
+  void didFinish() noexcept;
+
+private:
+  std::mutex _mutex;
+  bool _isResolved = false;
+  std::exception_ptr _error;
+  std::vector<OnResolvedFunc> _onResolvedListeners;
+  std::vector<OnRejectedFunc> _onRejectedListeners;
+};
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/PromiseType.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/PromiseType.hpp
new file mode 100644
index 0000000..7efbd66
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/PromiseType.hpp
@@ -0,0 +1,44 @@
+//
+//  PromiseType.hpp
+//  NitroModules
+//
+//  Created by Marc Rousavy on 09.12.24.
+//
+
+#pragma once
+
+#include "Promise.hpp"
+#include <type_traits>
+
+namespace margelo::nitro {
+
+// Gets the `T` in `Promise<T>`.
+template <typename T>
+struct promise_type {
+  using type = void;
+  using is_promise = std::false_type;
+};
+
+template <>
+struct promise_type<void> {
+  using type = void;
+  using is_promise = std::true_type;
+};
+template <typename T>
+struct promise_type<Promise<T>> {
+  using type = T;
+  using is_promise = std::true_type;
+};
+template <typename T>
+struct promise_type<std::shared_ptr<Promise<T>>> {
+  using type = T;
+  using is_promise = std::true_type;
+};
+
+template <typename T>
+using promise_type_v = typename promise_type<std::remove_reference_t<T>>::type;
+
+template <typename T>
+inline constexpr bool is_promise_v = promise_type<std::remove_reference_t<T>>::is_promise::value;
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/Prototype.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/Prototype.hpp
new file mode 100644
index 0000000..7019337
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/Prototype.hpp
@@ -0,0 +1,182 @@
+//
+//  PrototypeChain.hpp
+//  NitroModules
+//
+//  Created by Marc Rousavy on 07.08.24.
+//
+
+#pragma once
+
+#include "HybridFunction.hpp"
+#include <memory>
+#include <string>
+#include <typeindex>
+#include <unordered_map>
+
+namespace margelo::nitro {
+
+/**
+ * Represents a Prototype's native C++ type ID.
+ * This can be used to identify a prototype against a C++ instance,
+ * or used as a cache-key.
+ */
+using NativeInstanceId = std::type_index;
+
+/**
+ * Represents a JS `Prototype`'s structure.
+ * Every prototype has a related C++ type ID (`instanceTypeId`).
+ * Prototypes can be sub-classes, in which case they have a `base` prototype.
+ * Each prototype has a list of methods, and properties (getters + setters).
+ *
+ * By using this `Prototype` structure, we can create JS objects that act
+ * as prototypes for `HybridObject`s.
+ *
+ * While a `Prototype` actually holds all the methods, a `HybridObject` only
+ * contains state and memory.
+ * This way the JS VM doesn't need to re-create methods for each `HybridObject`,
+ * they are only initialized once on the shared `Prototype`.
+ */
+struct Prototype final {
+private:
+  NativeInstanceId _instanceTypeId;
+  std::shared_ptr<Prototype> _base = nullptr;
+  std::unordered_map<std::string, HybridFunction> _methods;
+  std::unordered_map<std::string, HybridFunction> _getters;
+  std::unordered_map<std::string, HybridFunction> _setters;
+
+private:
+  Prototype(const NativeInstanceId& typeId, const std::shared_ptr<Prototype>& base) : _instanceTypeId(typeId), _base(base) {}
+
+public:
+  /**
+   * Gets a `Prototype` specification/node for the given native C++ type ID.
+   *
+   * If the given C++ type ID is unknown, a new `Prototype` node is created,
+   * which has to be initialized with methods, getters and setters first.
+   *
+   * If the given C++ type ID is already known in the static `Prototype` tree,
+   * a shared reference to it is returned.
+   */
+  static std::shared_ptr<Prototype> get(const NativeInstanceId& typeId, const std::shared_ptr<Prototype>& base = nullptr) {
+    static std::unordered_map<NativeInstanceId, std::shared_ptr<Prototype>> _prototypesCache;
+
+    const auto& found = _prototypesCache.find(typeId);
+    if (found != _prototypesCache.end()) {
+      // We know this C++ type ID / Prototype - return it!
+      return found->second;
+    } else {
+      // This is the first time we see this C++ type ID - create a new base Prototype for this.
+      auto prototype = std::shared_ptr<Prototype>(new Prototype(typeId, base));
+      _prototypesCache.emplace(typeId, prototype);
+      return prototype;
+    }
+  }
+
+public:
+  template <typename T>
+  inline bool isNativeInstance() const noexcept {
+    return _instanceTypeId == std::type_index(typeid(T));
+  }
+
+  inline bool hasHybrids() const {
+    return !_methods.empty() || !_getters.empty() || !_setters.empty();
+  }
+
+  inline bool hasBase() const noexcept {
+    return _base != nullptr;
+  }
+  inline const std::shared_ptr<Prototype>& getBase() const noexcept {
+    return _base;
+  }
+  inline const NativeInstanceId& getNativeInstanceId() const noexcept {
+    return _instanceTypeId;
+  }
+  inline const std::unordered_map<std::string, HybridFunction>& getMethods() const noexcept {
+    return _methods;
+  }
+  inline const std::unordered_map<std::string, HybridFunction>& getGetters() const noexcept {
+    return _getters;
+  }
+  inline const std::unordered_map<std::string, HybridFunction>& getSetters() const noexcept {
+    return _setters;
+  }
+
+public:
+  /**
+   * Registers the given C++ method as a property getter that can be called from JS, through the object's Prototype.
+   * Example:
+   * ```cpp
+   * registerHybridGetter("foo", &MyObject::getFoo);
+   * ```
+   */
+  template <typename Derived, typename ReturnType>
+  inline void registerHybridGetter(std::string name, InstanceMethod<Derived, ReturnType> method) {
+    if (_getters.contains(name)) [[unlikely]] {
+      throw std::runtime_error("Cannot add Hybrid Property Getter \"" + name + "\" - a getter with that name already exists!");
+    }
+    if (_methods.contains(name)) [[unlikely]] {
+      throw std::runtime_error("Cannot add Hybrid Property Getter \"" + name + "\" - a method with that name already exists!");
+    }
+
+    _getters.emplace(name, HybridFunction::createHybridFunction(name, method, FunctionKind::GETTER));
+  }
+
+  /**
+   * Registers the given C++ method as a property setter that can be called from JS, through the object's Prototype.
+   * Example:
+   * ```cpp
+   * registerHybridSetter("foo", &MyObject::setFoo);
+   * ```
+   */
+  template <typename Derived, typename ValueType>
+  inline void registerHybridSetter(std::string name, InstanceMethod<Derived, void, ValueType> method) {
+    if (_setters.contains(name)) [[unlikely]] {
+      throw std::runtime_error("Cannot add Hybrid Property Setter \"" + name + "\" - a setter with that name already exists!");
+    }
+    if (_methods.contains(name)) [[unlikely]] {
+      throw std::runtime_error("Cannot add Hybrid Property Setter \"" + name + "\" - a method with that name already exists!");
+    }
+
+    _setters.emplace(name, HybridFunction::createHybridFunction(name, method, FunctionKind::SETTER));
+  }
+
+  /**
+   * Registers the given C++ method as a Hybrid Method that can be called from JS, through the object's Prototype.
+   * Example:
+   * ```cpp
+   * registerHybridMethod("sayHello", &MyObject::sayHello);
+   * ```
+   */
+  template <typename Derived, typename ReturnType, typename... Args>
+  inline void registerHybridMethod(std::string name, InstanceMethod<Derived, ReturnType, Args...> method) {
+    if (_getters.contains(name) || _setters.contains(name)) [[unlikely]] {
+      throw std::runtime_error("Cannot add Hybrid Method \"" + name + "\" - a property with that name already exists!");
+    }
+    if (_methods.contains(name)) [[unlikely]] {
+      throw std::runtime_error("Cannot add Hybrid Method \"" + name + "\" - a method with that name already exists!");
+    }
+
+    _methods.emplace(name, HybridFunction::createHybridFunction(name, method, FunctionKind::METHOD));
+  }
+
+  /**
+   * Registers the given raw JSI C++ method as a Hybrid Method that can be called from JS, through the object's Prototype.
+   * Example:
+   * ```cpp
+   * registerRawHybridMethod("sayHello", &MyObject::sayHello);
+   * ```
+   */
+  template <typename Derived>
+  inline void registerRawHybridMethod(std::string name, size_t expectedArgumentsCount, RawInstanceMethod<Derived> method) {
+    if (_getters.contains(name) || _setters.contains(name)) [[unlikely]] {
+      throw std::runtime_error("Cannot add Hybrid Method \"" + name + "\" - a property with that name already exists!");
+    }
+    if (_methods.contains(name)) [[unlikely]] {
+      throw std::runtime_error("Cannot add Hybrid Method \"" + name + "\" - a method with that name already exists!");
+    }
+
+    _methods.emplace(name, HybridFunction::createRawHybridFunction(name, expectedArgumentsCount, method));
+  }
+};
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/PrototypeChain.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/PrototypeChain.hpp
new file mode 100644
index 0000000..34dcf8f
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/PrototypeChain.hpp
@@ -0,0 +1,78 @@
+//
+//  PrototypeChain.hpp
+//  NitroModules
+//
+//  Created by Marc Rousavy on 07.08.24.
+//
+
+#pragma once
+
+#include "Prototype.hpp"
+
+namespace margelo::nitro {
+
+/**
+ * Represents a mutable chain of prototypes.
+ * Callers can use this class to incrementally add sub-classes to prototypes and build
+ * prototype chains/trees using C++ type information.
+ *
+ * The template methods can be used to find a specific C++ instance in the prototype tree,
+ * or create a new sub-class if it cannot be found.
+ */
+class PrototypeChain final {
+private:
+  std::shared_ptr<Prototype> _prototype;
+
+public:
+  PrototypeChain() {}
+
+public:
+  /**
+   * Gets the current `Prototype` as a whole.
+   * This does not do any modifications to the Prototype tree.
+   */
+  inline const std::shared_ptr<Prototype>& getPrototype() const {
+    return _prototype;
+  }
+
+public:
+  /**
+   * Extends the Prototype with the given type `Derived`.
+   * If the Prototype already extended `Derived`, this returns the current state.
+   */
+  template <typename Derived>
+  inline const std::shared_ptr<Prototype>& extendPrototype() {
+    if (_prototype == nullptr) {
+      _prototype = Prototype::get(typeid(Derived));
+    }
+
+    return getOrExtendPrototype<Derived>(_prototype);
+  }
+
+private:
+  /**
+   * Perform a bottom-down search of the given `Derived` C++ type info.
+   * If the current prototype tree does not have a Prototype that represents the
+   * C++ type `Derived`, it will extend it at the bottom and shift the `Prototype` tree
+   * up by one.
+   */
+  template <typename Derived>
+  inline const std::shared_ptr<Prototype>& getOrExtendPrototype(const std::shared_ptr<Prototype>& node) {
+    if (node->isNativeInstance<Derived>()) {
+      // If the Prototype represents the caller type (`Derived`), we work with this Prototype.
+      return node;
+    } else {
+      if (node->hasBase()) {
+        // We didn't find a match in this prototype, let's recursively try it's parent!
+        return getOrExtendPrototype<Derived>(node->getBase());
+      } else {
+        // We didn't find `Derived` and we don't have a base- add a child and shift the tree by one.
+        auto newBase = _prototype;
+        _prototype = Prototype::get(typeid(Derived), newBase);
+        return _prototype;
+      }
+    }
+  }
+};
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/ReferenceState.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/ReferenceState.hpp
new file mode 100644
index 0000000..ae946e5
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/ReferenceState.hpp
@@ -0,0 +1,40 @@
+//
+//  ReferenceState.hpp
+//  react-native-nitro
+//
+//  Created by Marc Rousavy on 03.02.24.
+//
+
+#pragma once
+
+#include <atomic>
+#include <mutex>
+
+namespace margelo::nitro {
+
+/**
+ * Holds state for an `BorrowingReference` (or `WeakReference`).
+ *
+ * The state tracks the amount of strong- and weak- references to any kind of value,
+ * including an extra `isDeleted` flag that specifies whether the value has been force-deleted.
+ *
+ * Also, a `mutex` allows for thread-safe access of the `isDeleted` flag.
+ */
+struct ReferenceState {
+  std::atomic_size_t strongRefCount;
+  std::atomic_size_t weakRefCount;
+  bool isDeleted;
+  std::mutex mutex;
+
+  /**
+   * Decrements the strong ref count by one, and returns whether the value should be deleted.
+   */
+  inline bool decrementStrongRefCount() {
+    size_t oldRefCount = strongRefCount.fetch_sub(1);
+    return oldRefCount <= 1;
+  }
+
+  explicit ReferenceState() : strongRefCount(1), weakRefCount(0), isDeleted(false) {}
+};
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/ThreadPool.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/ThreadPool.hpp
new file mode 100644
index 0000000..6437b31
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/ThreadPool.hpp
@@ -0,0 +1,66 @@
+//
+//  ThreadPool.hpp
+//  NitroModules
+//
+//  Created by Marc Rousavy on 21.06.24.
+//
+
+#pragma once
+
+#include "NitroDefines.hpp"
+#include <atomic>
+#include <condition_variable>
+#include <functional>
+#include <memory>
+#include <mutex>
+#include <queue>
+#include <string>
+#include <thread>
+#include <vector>
+
+namespace margelo::nitro {
+
+class ThreadPool final {
+public:
+  /**
+   * Create a new ThreadPool with the given number of minimum workers/threads.
+   * The Thread Pool can expand on the fly if it is busy.
+   */
+  explicit ThreadPool(const char* NON_NULL const name, size_t initialThreadsCount, size_t maxThreadsCount);
+  ~ThreadPool();
+  ThreadPool(const ThreadPool&) = delete;
+  ThreadPool(ThreadPool&&) = delete;
+
+  /**
+   * Schedules the given task asynchronously on the ThreadPool.
+   * It will run once a worker is available.
+   */
+  void run(std::function<void()>&& task);
+
+private:
+  /**
+   * Adds a new Thread to the current Thread Pool.
+   * This grows the size by one, and potentially starts work sooner if other Threads are busy.
+   */
+  void addThread();
+
+public:
+  /**
+   * Get a static singleton instance - a shared ThreadPool.
+   * The shared ThreadPool has 3 threads.
+   */
+  static ThreadPool& shared();
+
+private:
+  std::vector<std::thread> _workers;
+  std::queue<std::function<void()>> _tasks;
+  std::mutex _queueMutex;
+  std::condition_variable _condition;
+  std::atomic<bool> _isAlive;
+  std::atomic<size_t> _threadCount;
+  size_t _threadCountLimit;
+  const char* NON_NULL _name;
+  static constexpr auto TAG = "ThreadPool";
+};
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/ThreadUtils.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/ThreadUtils.hpp
new file mode 100644
index 0000000..aa249c1
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/ThreadUtils.hpp
@@ -0,0 +1,31 @@
+//
+//  ThreadUtils.hpp
+//  react-native-nitro
+//
+//  Created by Marc Rousavy on 14.07.24.
+//
+
+#pragma once
+
+#include <string>
+
+namespace margelo::nitro {
+
+class ThreadUtils final {
+public:
+  ThreadUtils() = delete;
+
+  /**
+   * Get the current Thread's name.
+   * This is implemented differently on iOS and Android.
+   */
+  static std::string getThreadName();
+
+  /**
+   * Set the current Thread's name.
+   * This is implemented differently on iOS and Android.
+   */
+  static void setThreadName(const std::string& name);
+};
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/TypeIndex.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/TypeIndex.hpp
new file mode 100644
index 0000000..a4114b8
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/TypeIndex.hpp
@@ -0,0 +1,29 @@
+//
+//  TypeIndex.hpp
+//  NitroModules
+//
+//  Created by Marc Rousavy on 21.06.24.
+//
+
+#pragma once
+
+#include <tuple>
+#include <type_traits>
+
+namespace margelo::nitro {
+
+// Gets the index of `T` in a `std::tuple<...>`.
+template <typename T, typename... Ts>
+struct type_index;
+
+template <typename T, typename First, typename... Rest>
+struct type_index<T, First, Rest...> {
+  static constexpr size_t value = std::is_same_v<T, First> ? 0 : 1 + type_index<T, Rest...>::value;
+};
+
+template <typename T>
+struct type_index<T> {
+  static constexpr size_t value = -1; // Type not found
+};
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/WeakReference+Owning.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/WeakReference+Owning.hpp
new file mode 100644
index 0000000..3650479
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/WeakReference+Owning.hpp
@@ -0,0 +1,33 @@
+//
+//  WeakReference+Owning.hpp
+//  react-native-nitro
+//
+//  Created by Marc Rousavy on 23.06.24.
+//
+
+#pragma once
+
+#include "BorrowingReference.hpp"
+
+namespace margelo::nitro {
+
+template <typename T>
+WeakReference<T>::WeakReference(const BorrowingReference<T>& ref) {
+  _value = ref._value;
+  _state = ref._state;
+  _state->weakRefCount++;
+}
+
+template <typename T>
+BorrowingReference<T> WeakReference<T>::lock() const {
+  std::unique_lock lock(_state->mutex);
+
+  if (_state->isDeleted) {
+    // return nullptr
+    return BorrowingReference<T>();
+  }
+
+  return BorrowingReference(*this);
+}
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/WeakReference.hpp b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/WeakReference.hpp
new file mode 100644
index 0000000..23868fa
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/headers/nitromodules/NitroModules/WeakReference.hpp
@@ -0,0 +1,102 @@
+//
+//  WeakReference.hpp
+//  NitroModules
+//
+//  Created by Marc Rousavy on 21.06.24.
+//
+
+#pragma once
+
+#include "NitroDefines.hpp"
+#include "ReferenceState.hpp"
+#include <atomic>
+#include <cstddef>
+#include <mutex>
+
+namespace margelo::nitro {
+
+// forward-declaration to avoid duplicate symbols
+template <typename T>
+class BorrowingReference;
+
+/**
+ A `WeakReference<T>` is a weak reference to a pointer created by `BorrowingReference<T>`.
+ It can be locked to gain a strong `BorrowingReference<T>` again if it has not been deleted yet.
+ */
+template <typename T>
+class WeakReference final {
+private:
+  explicit WeakReference(const BorrowingReference<T>& ref);
+
+public:
+  WeakReference() : _value(nullptr), _state(nullptr) {}
+
+  WeakReference(const WeakReference& ref) : _value(ref._value), _state(ref._state) {
+    if (_state != nullptr) {
+      // increment ref count after copy
+      _state->weakRefCount++;
+    }
+  }
+
+  WeakReference(WeakReference&& ref) : _value(ref._value), _state(ref._state) {
+    // Remove state from other WeakReference after moving since it's now stale data
+    ref._value = nullptr;
+    ref._state = nullptr;
+  }
+
+  WeakReference& operator=(const WeakReference& ref) {
+    if (this == &ref)
+      return *this;
+
+    if (_state != nullptr) {
+      // destroy previous pointer
+      _state->weakRefCount--;
+      maybeDestroy();
+    }
+
+    _value = ref._value;
+    _state = ref._state;
+    if (_state != nullptr) {
+      // increment new pointer
+      _state->weakRefCount++;
+    }
+
+    return *this;
+  }
+
+  ~WeakReference() {
+    if (_state != nullptr) {
+      _state->weakRefCount--;
+      maybeDestroy();
+    }
+  }
+
+  /**
+   Try to lock the borrowing reference to an owning reference, or `nullptr` if it has already been deleted.
+   */
+  [[nodiscard]]
+  BorrowingReference<T> lock() const;
+
+public:
+  friend class BorrowingReference<T>;
+
+private:
+  void maybeDestroy() {
+    if (_state->strongRefCount == 0 && _state->weakRefCount == 0) {
+      // free the full memory if there are no more references at all
+      if (!_state->isDeleted) [[unlikely]] {
+        std::string typeName = TypeInfo::getFriendlyTypename<T>(true);
+        throw std::runtime_error("WeakReference<" + typeName + "> encountered a stale `_value` - BorrowingReference<" + typeName +
+                                 "> should've already deleted this!");
+      }
+      delete _state;
+      _state = nullptr;
+    }
+  }
+
+private:
+  T* NULLABLE _value;
+  ReferenceState* NON_NULL _state;
+};
+
+} // namespace margelo::nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/intermediates/aapt_friendly_merged_manifests/debug/processDebugManifest/aapt/AndroidManifest.xml b/node_modules/react-native-nitro-modules/android/build/intermediates/aapt_friendly_merged_manifests/debug/processDebugManifest/aapt/AndroidManifest.xml
new file mode 100644
index 0000000..0869281
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/intermediates/aapt_friendly_merged_manifests/debug/processDebugManifest/aapt/AndroidManifest.xml
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.margelo.nitro" >
+
+    <uses-sdk android:minSdkVersion="24" />
+
+</manifest>
\ No newline at end of file
diff --git a/node_modules/react-native-nitro-modules/android/build/intermediates/aapt_friendly_merged_manifests/debug/processDebugManifest/aapt/output-metadata.json b/node_modules/react-native-nitro-modules/android/build/intermediates/aapt_friendly_merged_manifests/debug/processDebugManifest/aapt/output-metadata.json
new file mode 100644
index 0000000..1247a06
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/intermediates/aapt_friendly_merged_manifests/debug/processDebugManifest/aapt/output-metadata.json
@@ -0,0 +1,18 @@
+{
+  "version": 3,
+  "artifactType": {
+    "type": "AAPT_FRIENDLY_MERGED_MANIFESTS",
+    "kind": "Directory"
+  },
+  "applicationId": "com.margelo.nitro",
+  "variantName": "debug",
+  "elements": [
+    {
+      "type": "SINGLE",
+      "filters": [],
+      "attributes": [],
+      "outputFile": "AndroidManifest.xml"
+    }
+  ],
+  "elementType": "File"
+}
\ No newline at end of file
diff --git a/node_modules/react-native-nitro-modules/android/build/intermediates/aar_metadata/debug/writeDebugAarMetadata/aar-metadata.properties b/node_modules/react-native-nitro-modules/android/build/intermediates/aar_metadata/debug/writeDebugAarMetadata/aar-metadata.properties
new file mode 100644
index 0000000..1211b1e
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/intermediates/aar_metadata/debug/writeDebugAarMetadata/aar-metadata.properties
@@ -0,0 +1,6 @@
+aarFormatVersion=1.0
+aarMetadataVersion=1.0
+minCompileSdk=1
+minCompileSdkExtension=0
+minAndroidGradlePluginVersion=1.0.0
+coreLibraryDesugaringEnabled=false
diff --git a/node_modules/react-native-nitro-modules/android/build/intermediates/annotation_processor_list/debug/javaPreCompileDebug/annotationProcessors.json b/node_modules/react-native-nitro-modules/android/build/intermediates/annotation_processor_list/debug/javaPreCompileDebug/annotationProcessors.json
new file mode 100644
index 0000000..9e26dfe
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/intermediates/annotation_processor_list/debug/javaPreCompileDebug/annotationProcessors.json
@@ -0,0 +1 @@
+{}
\ No newline at end of file
diff --git a/node_modules/react-native-nitro-modules/android/build/intermediates/compile_r_class_jar/debug/generateDebugRFile/R.jar b/node_modules/react-native-nitro-modules/android/build/intermediates/compile_r_class_jar/debug/generateDebugRFile/R.jar
new file mode 100644
index 0000000..dcd92c5
Binary files /dev/null and b/node_modules/react-native-nitro-modules/android/build/intermediates/compile_r_class_jar/debug/generateDebugRFile/R.jar differ
diff --git a/node_modules/react-native-nitro-modules/android/build/intermediates/compile_symbol_list/debug/generateDebugRFile/R.txt b/node_modules/react-native-nitro-modules/android/build/intermediates/compile_symbol_list/debug/generateDebugRFile/R.txt
new file mode 100644
index 0000000..e69de29
diff --git a/node_modules/react-native-nitro-modules/android/build/intermediates/incremental/debug/packageDebugResources/compile-file-map.properties b/node_modules/react-native-nitro-modules/android/build/intermediates/incremental/debug/packageDebugResources/compile-file-map.properties
new file mode 100644
index 0000000..ab64965
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/intermediates/incremental/debug/packageDebugResources/compile-file-map.properties
@@ -0,0 +1 @@
+#Thu Dec 11 16:11:39 WET 2025
diff --git a/node_modules/react-native-nitro-modules/android/build/intermediates/incremental/debug/packageDebugResources/merger.xml b/node_modules/react-native-nitro-modules/android/build/intermediates/incremental/debug/packageDebugResources/merger.xml
new file mode 100644
index 0000000..b879b55
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/intermediates/incremental/debug/packageDebugResources/merger.xml
@@ -0,0 +1,2 @@
+<?xml version="1.0" encoding="utf-8"?>
+<merger version="3"><dataSet aapt-namespace="http://schemas.android.com/apk/res-auto" config="main$Generated" generated="true" ignore_pattern="!.svn:!.git:!.ds_store:!*.scc:.*:&lt;dir>_*:!CVS:!thumbs.db:!picasa.ini:!*~"><source path="/Users/jonathan.ferreira/development/repos/vechain/veworld-mobile/node_modules/react-native-nitro-modules/android/src/main/res"/></dataSet><dataSet aapt-namespace="http://schemas.android.com/apk/res-auto" config="main" generated-set="main$Generated" ignore_pattern="!.svn:!.git:!.ds_store:!*.scc:.*:&lt;dir>_*:!CVS:!thumbs.db:!picasa.ini:!*~"><source path="/Users/jonathan.ferreira/development/repos/vechain/veworld-mobile/node_modules/react-native-nitro-modules/android/src/main/res"/></dataSet><dataSet aapt-namespace="http://schemas.android.com/apk/res-auto" config="debug$Generated" generated="true" ignore_pattern="!.svn:!.git:!.ds_store:!*.scc:.*:&lt;dir>_*:!CVS:!thumbs.db:!picasa.ini:!*~"><source path="/Users/jonathan.ferreira/development/repos/vechain/veworld-mobile/node_modules/react-native-nitro-modules/android/src/debug/res"/></dataSet><dataSet aapt-namespace="http://schemas.android.com/apk/res-auto" config="debug" generated-set="debug$Generated" ignore_pattern="!.svn:!.git:!.ds_store:!*.scc:.*:&lt;dir>_*:!CVS:!thumbs.db:!picasa.ini:!*~"><source path="/Users/jonathan.ferreira/development/repos/vechain/veworld-mobile/node_modules/react-native-nitro-modules/android/src/debug/res"/></dataSet><dataSet aapt-namespace="http://schemas.android.com/apk/res-auto" config="generated$Generated" generated="true" ignore_pattern="!.svn:!.git:!.ds_store:!*.scc:.*:&lt;dir>_*:!CVS:!thumbs.db:!picasa.ini:!*~"><source path="/Users/jonathan.ferreira/development/repos/vechain/veworld-mobile/node_modules/react-native-nitro-modules/android/build/generated/res/resValues/debug"/></dataSet><dataSet aapt-namespace="http://schemas.android.com/apk/res-auto" config="generated" generated-set="generated$Generated" ignore_pattern="!.svn:!.git:!.ds_store:!*.scc:.*:&lt;dir>_*:!CVS:!thumbs.db:!picasa.ini:!*~"><source path="/Users/jonathan.ferreira/development/repos/vechain/veworld-mobile/node_modules/react-native-nitro-modules/android/build/generated/res/resValues/debug"/></dataSet><mergedItems/></merger>
\ No newline at end of file
diff --git a/node_modules/react-native-nitro-modules/android/build/intermediates/local_only_symbol_list/debug/parseDebugLocalResources/R-def.txt b/node_modules/react-native-nitro-modules/android/build/intermediates/local_only_symbol_list/debug/parseDebugLocalResources/R-def.txt
new file mode 100644
index 0000000..78ac5b8
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/intermediates/local_only_symbol_list/debug/parseDebugLocalResources/R-def.txt
@@ -0,0 +1,2 @@
+R_DEF: Internal format may change without notice
+local
diff --git a/node_modules/react-native-nitro-modules/android/build/intermediates/manifest_merge_blame_file/debug/processDebugManifest/manifest-merger-blame-debug-report.txt b/node_modules/react-native-nitro-modules/android/build/intermediates/manifest_merge_blame_file/debug/processDebugManifest/manifest-merger-blame-debug-report.txt
new file mode 100644
index 0000000..e54f8cb
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/intermediates/manifest_merge_blame_file/debug/processDebugManifest/manifest-merger-blame-debug-report.txt
@@ -0,0 +1,7 @@
+1<?xml version="1.0" encoding="utf-8"?>
+2<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+3    package="com.margelo.nitro" >
+4
+5    <uses-sdk android:minSdkVersion="24" />
+6
+7</manifest>
diff --git a/node_modules/react-native-nitro-modules/android/build/intermediates/merged_manifest/debug/processDebugManifest/AndroidManifest.xml b/node_modules/react-native-nitro-modules/android/build/intermediates/merged_manifest/debug/processDebugManifest/AndroidManifest.xml
new file mode 100644
index 0000000..0869281
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/intermediates/merged_manifest/debug/processDebugManifest/AndroidManifest.xml
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.margelo.nitro" >
+
+    <uses-sdk android:minSdkVersion="24" />
+
+</manifest>
\ No newline at end of file
diff --git a/node_modules/react-native-nitro-modules/android/build/intermediates/navigation_json/debug/extractDeepLinksDebug/navigation.json b/node_modules/react-native-nitro-modules/android/build/intermediates/navigation_json/debug/extractDeepLinksDebug/navigation.json
new file mode 100644
index 0000000..0637a08
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/intermediates/navigation_json/debug/extractDeepLinksDebug/navigation.json
@@ -0,0 +1 @@
+[]
\ No newline at end of file
diff --git a/node_modules/react-native-nitro-modules/android/build/intermediates/nested_resources_validation_report/debug/generateDebugResources/nestedResourcesValidationReport.txt b/node_modules/react-native-nitro-modules/android/build/intermediates/nested_resources_validation_report/debug/generateDebugResources/nestedResourcesValidationReport.txt
new file mode 100644
index 0000000..08f4ebe
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/intermediates/nested_resources_validation_report/debug/generateDebugResources/nestedResourcesValidationReport.txt
@@ -0,0 +1 @@
+0 Warning/Error
\ No newline at end of file
diff --git a/node_modules/react-native-nitro-modules/android/build/intermediates/prefab_package_header_only/prefab_publication.json/debug b/node_modules/react-native-nitro-modules/android/build/intermediates/prefab_package_header_only/prefab_publication.json/debug
new file mode 100644
index 0000000..280e2f9
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/intermediates/prefab_package_header_only/prefab_publication.json/debug
@@ -0,0 +1,17 @@
+{
+  "installationFolder": "/Users/jonathan.ferreira/development/repos/vechain/veworld-mobile/node_modules/react-native-nitro-modules/android/build/intermediates/prefab_package/debug/prefab",
+  "gradlePath": ":react-native-nitro-modules",
+  "packageInfo": {
+    "packageName": "react-native-nitro-modules",
+    "packageSchemaVersion": 2,
+    "packageDependencies": [],
+    "modules": [
+      {
+        "moduleName": "NitroModules",
+        "moduleHeaders": "/Users/jonathan.ferreira/development/repos/vechain/veworld-mobile/node_modules/react-native-nitro-modules/android/build/headers/nitromodules",
+        "moduleExportLibraries": [],
+        "abis": []
+      }
+    ]
+  }
+}
\ No newline at end of file
diff --git a/node_modules/react-native-nitro-modules/android/build/intermediates/prefab_package_header_only/prefab_publication.json/release b/node_modules/react-native-nitro-modules/android/build/intermediates/prefab_package_header_only/prefab_publication.json/release
new file mode 100644
index 0000000..76e9c6e
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/intermediates/prefab_package_header_only/prefab_publication.json/release
@@ -0,0 +1,17 @@
+{
+  "installationFolder": "/Users/jonathan.ferreira/development/repos/vechain/veworld-mobile/node_modules/react-native-nitro-modules/android/build/intermediates/prefab_package/release/prefab",
+  "gradlePath": ":react-native-nitro-modules",
+  "packageInfo": {
+    "packageName": "react-native-nitro-modules",
+    "packageSchemaVersion": 2,
+    "packageDependencies": [],
+    "modules": [
+      {
+        "moduleName": "NitroModules",
+        "moduleHeaders": "/Users/jonathan.ferreira/development/repos/vechain/veworld-mobile/node_modules/react-native-nitro-modules/android/build/headers/nitromodules",
+        "moduleExportLibraries": [],
+        "abis": []
+      }
+    ]
+  }
+}
\ No newline at end of file
diff --git a/node_modules/react-native-nitro-modules/android/build/intermediates/symbol_list_with_package_name/debug/generateDebugRFile/package-aware-r.txt b/node_modules/react-native-nitro-modules/android/build/intermediates/symbol_list_with_package_name/debug/generateDebugRFile/package-aware-r.txt
new file mode 100644
index 0000000..f3444ac
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/intermediates/symbol_list_with_package_name/debug/generateDebugRFile/package-aware-r.txt
@@ -0,0 +1 @@
+com.margelo.nitro
diff --git a/node_modules/react-native-nitro-modules/android/build/kotlin/compileDebugKotlin/cacheable/dirty-sources.txt b/node_modules/react-native-nitro-modules/android/build/kotlin/compileDebugKotlin/cacheable/dirty-sources.txt
new file mode 100644
index 0000000..bcc0cae
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/kotlin/compileDebugKotlin/cacheable/dirty-sources.txt
@@ -0,0 +1,12 @@
+/Users/jonathan.ferreira/development/repos/vechain/veworld-mobile/node_modules/react-native-nitro-modules/android/src/main/java/com/margelo/nitro/utils/HardwareBufferUtils.kt
+/Users/jonathan.ferreira/development/repos/vechain/veworld-mobile/node_modules/react-native-nitro-modules/android/src/main/java/com/margelo/nitro/core/AnyMap.kt
+/Users/jonathan.ferreira/development/repos/vechain/veworld-mobile/node_modules/react-native-nitro-modules/android/src/main/java/com/margelo/nitro/NitroModules.kt
+/Users/jonathan.ferreira/development/repos/vechain/veworld-mobile/node_modules/react-native-nitro-modules/android/src/main/java/com/margelo/nitro/core/Null.kt
+/Users/jonathan.ferreira/development/repos/vechain/veworld-mobile/node_modules/react-native-nitro-modules/android/src/main/java/com/margelo/nitro/NitroModulesPackage.kt
+/Users/jonathan.ferreira/development/repos/vechain/veworld-mobile/node_modules/react-native-nitro-modules/android/src/main/java/com/margelo/nitro/core/ArrayBuffer.kt
+/Users/jonathan.ferreira/development/repos/vechain/veworld-mobile/node_modules/react-native-nitro-modules/android/src/main/java/com/margelo/nitro/utils/HardwareBuffer+updateFrom.kt
+/Users/jonathan.ferreira/development/repos/vechain/veworld-mobile/node_modules/react-native-nitro-modules/android/src/main/java/com/margelo/nitro/core/Promise.kt
+/Users/jonathan.ferreira/development/repos/vechain/veworld-mobile/node_modules/react-native-nitro-modules/android/src/main/java/com/margelo/nitro/core/AnyValue.kt
+/Users/jonathan.ferreira/development/repos/vechain/veworld-mobile/node_modules/react-native-nitro-modules/android/src/main/java/com/margelo/nitro/core/HybridObject.kt
+/Users/jonathan.ferreira/development/repos/vechain/veworld-mobile/node_modules/react-native-nitro-modules/android/src/main/java/com/margelo/nitro/views/HybridView.kt
+/Users/jonathan.ferreira/development/repos/vechain/veworld-mobile/node_modules/react-native-nitro-modules/android/src/oldarch/NitroModulesSpec.kt
\ No newline at end of file
diff --git a/node_modules/react-native-nitro-modules/android/build/kotlin/compileDebugKotlin/local-state/build-history.bin b/node_modules/react-native-nitro-modules/android/build/kotlin/compileDebugKotlin/local-state/build-history.bin
new file mode 100644
index 0000000..7b48583
Binary files /dev/null and b/node_modules/react-native-nitro-modules/android/build/kotlin/compileDebugKotlin/local-state/build-history.bin differ
diff --git a/node_modules/react-native-nitro-modules/android/build/outputs/logs/manifest-merger-debug-report.txt b/node_modules/react-native-nitro-modules/android/build/outputs/logs/manifest-merger-debug-report.txt
new file mode 100644
index 0000000..34a2309
--- /dev/null
+++ b/node_modules/react-native-nitro-modules/android/build/outputs/logs/manifest-merger-debug-report.txt
@@ -0,0 +1,16 @@
+-- Merging decision tree log ---
+manifest
+ADDED from /Users/jonathan.ferreira/development/repos/vechain/veworld-mobile/node_modules/react-native-nitro-modules/android/src/main/AndroidManifest.xml:1:1-2:12
+INJECTED from /Users/jonathan.ferreira/development/repos/vechain/veworld-mobile/node_modules/react-native-nitro-modules/android/src/main/AndroidManifest.xml:1:1-2:12
+	package
+		INJECTED from /Users/jonathan.ferreira/development/repos/vechain/veworld-mobile/node_modules/react-native-nitro-modules/android/src/main/AndroidManifest.xml
+	xmlns:android
+		ADDED from /Users/jonathan.ferreira/development/repos/vechain/veworld-mobile/node_modules/react-native-nitro-modules/android/src/main/AndroidManifest.xml:1:11-69
+uses-sdk
+INJECTED from /Users/jonathan.ferreira/development/repos/vechain/veworld-mobile/node_modules/react-native-nitro-modules/android/src/main/AndroidManifest.xml reason: use-sdk injection requested
+INJECTED from /Users/jonathan.ferreira/development/repos/vechain/veworld-mobile/node_modules/react-native-nitro-modules/android/src/main/AndroidManifest.xml
+INJECTED from /Users/jonathan.ferreira/development/repos/vechain/veworld-mobile/node_modules/react-native-nitro-modules/android/src/main/AndroidManifest.xml
+	android:targetSdkVersion
+		INJECTED from /Users/jonathan.ferreira/development/repos/vechain/veworld-mobile/node_modules/react-native-nitro-modules/android/src/main/AndroidManifest.xml
+	android:minSdkVersion
+		INJECTED from /Users/jonathan.ferreira/development/repos/vechain/veworld-mobile/node_modules/react-native-nitro-modules/android/src/main/AndroidManifest.xml
diff --git a/node_modules/react-native-nitro-modules/android/src/main/java/com/margelo/nitro/NitroModulesPackage.kt b/node_modules/react-native-nitro-modules/android/src/main/java/com/margelo/nitro/NitroModulesPackage.kt
index f55986b..4a931b9 100644
--- a/node_modules/react-native-nitro-modules/android/src/main/java/com/margelo/nitro/NitroModulesPackage.kt
+++ b/node_modules/react-native-nitro-modules/android/src/main/java/com/margelo/nitro/NitroModulesPackage.kt
@@ -26,10 +26,10 @@ class NitroModulesPackage : BaseReactPackage() {
         ReactModuleInfo(
           NitroModules.NAME,
           NitroModules.NAME,
-          canOverrideExistingModule = false,
-          needsEagerInit = false,
-          isCxxModule = false,
-          isTurboModule = isTurboModule,
+          false, // canOverrideExistingModule
+          false, // needsEagerInit
+          false, // isCxxModule
+          isTurboModule,
         )
       moduleInfos
     }
